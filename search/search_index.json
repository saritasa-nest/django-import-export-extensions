{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"django-import-export-extensions","text":""},{"location":"#links","title":"Links","text":"<ul> <li>Documentation</li> <li>GitHub</li> <li>PyPI</li> <li>Contributing</li> <li>Changelog</li> </ul>"},{"location":"#description","title":"Description","text":"<p><code>django-import-export-extensions</code> extends the functionality of django-import-export adding the following features:</p> <ul> <li>Import/export resources in the background via Celery</li> <li>Manage import/export jobs via Django Admin</li> <li>DRF integration that allows to work with import/export jobs via API</li> <li>Support drf-spectacular generated API schema</li> <li>Additional fields and widgets (FileWidget, IntermediateManyToManyWidget, IntermediateManyToManyField)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>django-import-export-extensions</code>, run this command in your terminal:</p> <pre><code>pip install django-import-export-extensions\n</code></pre> <p>Add <code>import_export</code> and <code>import_export_extensions</code> to <code>INSTALLED_APPS</code></p> <pre><code># settings.py\nINSTALLED_APPS = (\n    ...,\n    \"import_export\",\n    \"import_export_extensions\",\n)\n</code></pre> <p>Run <code>migrate</code> command to create ImportJob/ExportJob models and <code>collectstatic</code> to let Django collect package static files to use in the admin.</p> <pre><code>python manage.py migrate\npython manage.py collectstatic\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Prepare resource for your model</p> <pre><code># apps/books/resources.py\nfrom import_export_extensions.resources import CeleryModelResource\n\nfrom .. import models\n\n\nclass BookResource(CeleryModelResource):\n\n    class Meta:\n        model = models.Book\n</code></pre> <p>Use <code>CeleryImportExportMixin</code> class and set <code>resource_classes</code> in admin model to import/export via Django Admin</p> <pre><code># apps/books/admin.py\nfrom django.contrib import admin\n\nfrom import_export_extensions.admin import CeleryImportExportMixin\n\nfrom .. import resources\n\n\n@admin.register(models.Book)\nclass BookAdmin(CeleryImportExportMixin, admin.ModelAdmin):\n    resource_classes = [resources.BookResource]\n</code></pre> <p>Prepare view sets to import/export via API</p> <pre><code># apps/books/api/views.py\nfrom .. import resources\n\nfrom import_export_extensions.api import views\n\n\nclass BookExportViewSet(views.ExportJobViewSet):\n    resource_class = resources.BookResource\n\n\nclass BookImportViewSet(views.ImportJobViewSet):\n    resource_class = resources.BookResource\n</code></pre> <p>Don't forget to configure Celery if you want to run import/export in background</p>"},{"location":"#license","title":"License","text":"<ul> <li>Free software: MIT license</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Support Django 6.0</li> <li>Keep the IDs of search and filter results from the admin, instead of using   a reimplementation of the Django admin code</li> <li>Migrate to MKDocs from Sphinx for documentation generation</li> <li>Minor improvements for import/export admins:</li> <li>Display <code>Created by</code> on detail page for export</li> <li>Add filter by <code>created</code> date both for export/import admin list pages</li> <li>Fix <code>created_by</code> for export by django-admin - now user who makes export     saves correct</li> <li>Rename <code>model</code> property to <code>Model</code> for export/import admin detail pages</li> </ul>"},{"location":"changelog/#192-2025-11-6","title":"1.9.2 (2025-11-6)","text":"<ul> <li>Change dependency versions constraints</li> </ul>"},{"location":"changelog/#191-2025-10-28","title":"1.9.1 (2025-10-28)","text":"<ul> <li>Support Python 3.14</li> </ul>"},{"location":"changelog/#190-2025-09-16","title":"1.9.0 (2025-09-16)","text":"<ul> <li>Improve filterset class initialization during fetching export queryset</li> <li>Add ability to customize the order of operation for export queryset</li> <li>Add ability to set dataset title</li> <li>Add field selection to the export confirmation page in the admin panel</li> <li>Add support to skip export confirmation page in admin     (https://github.com/saritasa-nest/django-import-export-extensions/issues/122):</li> <li>with <code>IMPORT_EXPORT_SKIP_ADMIN_EXPORT_UI=True</code> setting from original package</li> <li>with <code>skip_export_form</code> flag at the admin model level</li> </ul>"},{"location":"changelog/#180-2025-06-30","title":"1.8.0 (2025-06-30)","text":"<ul> <li>Add ability to disable celery task updates for resource</li> <li>Make that resources will always filter queryset on export if     filterset_class is present</li> </ul>"},{"location":"changelog/#170-2025-05-22","title":"1.7.0 (2025-05-22)","text":"<ul> <li>Add support using admin page filters for export</li> <li>Minor refactor of CeleryResourceMixin for easier overriding of export/import methods</li> <li>Add ability to pass additional args to <code>BaseFormat.export_data</code> on export</li> </ul>"},{"location":"changelog/#160-2025-04-29","title":"1.6.0 (2025-04-29)","text":"<ul> <li>Support Django 5.2</li> <li>Add support for customizing Django Admin forms for import/export</li> </ul>"},{"location":"changelog/#150-2025-04-02","title":"1.5.0 (2025-04-02)","text":"<ul> <li>Fix issue with long <code>error_message</code></li> <li>Add signals <code>export_job_failed</code> and     <code>import_job_failed</code> to respond to failed jobs.</li> <li>Add ability to specify storage via <code>STORAGES</code> setting     and alias <code>django_import_export_extensions</code></li> <li>Make possible to pass args/kwargs to import/export start action</li> </ul>"},{"location":"changelog/#141-2025-02-18","title":"1.4.1 (2025-02-18)","text":"<ul> <li>Make querysets more consistent for ViewSets</li> </ul>"},{"location":"changelog/#140-2025-01-28","title":"1.4.0 (2025-01-28)","text":"<ul> <li>Add explicit <code>created_by</code> argument to     <code>CeleryResourceMixin</code> and pass it in     <code>ExportJobSerializer</code> validation</li> <li>Add export/import action mixins     <code>api.mixins.ExportStartActionMixin</code> and     <code>api.mixins.ImportStartActionMixin</code></li> <li>Add <code>api.views.BaseExportJobViewSet</code>,     <code>BaseExportJobForUsersViewSet</code>,     <code>api.views.BaseImportJobViewSet</code> and     <code>BaseImportJobForUsersViewSet</code> for job management</li> </ul>"},{"location":"changelog/#131-2025-01-13","title":"1.3.1 (2025-01-13)","text":"<ul> <li>Fix issues with query params parsing</li> <li>Make <code>get_queryset</code> consistent for start actions</li> </ul>"},{"location":"changelog/#130-2025-01-09","title":"1.3.0 (2025-01-09)","text":"<ul> <li>Add base import/export views that only allow users to work with     their own jobs (<code>ImportJobForUserViewSet</code> and     <code>ExportJobForUserViewSet</code>).</li> <li>Small actions definition refactor in     <code>ExportJobViewSet/ExportJobViewSet</code> to allow easier     overriding.</li> <li>Add support for ordering in <code>export</code></li> <li>Add settings for DjangoFilterBackend and OrderingFilter in export api     <code>DRF_EXPORT_DJANGO_FILTERS_BACKEND</code> with default     <code>django_filters.rest_framework.DjangoFilterBackend</code> and     <code>DRF_EXPORT_ORDERING_BACKEND</code> with default     <code>rest_framework.filters.OrderingFilter</code>.</li> </ul>"},{"location":"changelog/#120-2024-12-26","title":"1.2.0 (2024-12-26)","text":"<ul> <li>Fix issue with slow export duration     (https://github.com/saritasa-nest/django-import-export-extensions/issues/79):</li> <li>Add setting <code>STATUS_UPDATE_ROW_COUNT</code> (default: 100) which       defines the number of rows after import/export of which the task       status is updated;</li> <li>Add ability to specify <code>status_update_row_count</code> for each         resource;</li> </ul>"},{"location":"changelog/#110-2024-12-06","title":"1.1.0 (2024-12-06)","text":"<ul> <li>Fix progress bar on changeview for ImportJob and ExportJob</li> <li>Improve celery-import-result page</li> <li>Add displaying resources for import form</li> <li>Fix autofill <code>Format</code> by file extension</li> <li>Add <code>Totals</code> section</li> <li>Remove extra loop if errors in input file       (https://github.com/saritasa-nest/django-import-export-extensions/issues/74)</li> <li>Fixed display of progress bar when task is waiting to run     (https://github.com/saritasa-nest/django-import-export-extensions/issues/68)</li> <li>Improve progress bar style     (https://github.com/saritasa-nest/django-import-export-extensions/issues/72)</li> <li>Set <code>default_auto_field</code> for <code>import-export-extensions</code> app to <code>django.db.models.BigAutoField</code>     (https://github.com/saritasa-nest/django-import-export-extensions/issues/69)</li> </ul>"},{"location":"changelog/#101-2024-11-08","title":"1.0.1 (2024-11-08)","text":"<ul> <li>Replaced <code>sphinx-rtd-theme</code> by furo</li> <li>Update/extend documentation</li> <li>Support Python 3.13</li> <li>Drop Django \\&lt;4.2 support</li> </ul>"},{"location":"changelog/#070-2024-10-29","title":"0.7.0 (2024-10-29)","text":"<ul> <li>Add support django-import-export &gt;= 4.2</li> <li>Removed support for django-import-export \\&lt; 4.2</li> <li>Improve test coverage</li> </ul>"},{"location":"changelog/#061-2024-10-04","title":"0.6.1 (2024-10-04)","text":"<ul> <li>Update requirements version and internal naming</li> </ul>"},{"location":"changelog/#060-2024-10-04","title":"0.6.0 (2024-10-04)","text":"<ul> <li>Extend response of import job api</li> <li>Added support for django-import-export &gt;= 4.0</li> <li>Removed support for django 3.2</li> <li>Add search and ordering to API views</li> <li>Removed <code>M2MField</code> since  <code>import_export.fields.Field</code> supports <code>m2m_add</code></li> </ul>"},{"location":"changelog/#050-2023-12-19","title":"0.5.0 (2023-12-19)","text":"<ul> <li>Drop support of python 3.9</li> <li>Migrate from pip-tools to poetry</li> <li>Add base model for <code>ImportJob</code> and <code>ExportJob</code></li> <li>Extend import results template: show validation errors in table</li> <li>Add force-import feature: skip rows with errors while importing</li> <li>Add <code>skip_parse_step</code> parameter for importing API</li> <li>Remove Makefile in favor of <code>invoke</code> commands</li> </ul>"},{"location":"changelog/#041-2023-09-25","title":"0.4.1 (2023-09-25)","text":"<ul> <li>Remove <code>escape_output</code> due it\\'s deprecation</li> </ul>"},{"location":"changelog/#040-2023-09-11","title":"0.4.0 (2023-09-11)","text":"<ul> <li>Make possible to pass <code>resource_kwargs</code> in ViewSets</li> <li>Remove filter_set from ImportViewSet</li> </ul>"},{"location":"changelog/#031-2023-09-11","title":"0.3.1 (2023-09-11)","text":"<ul> <li>Add more detailed documentation for package features</li> </ul>"},{"location":"changelog/#030-2023-09-11","title":"0.3.0 (2023-09-11)","text":"<ul> <li>Support settings from original package</li> </ul>"},{"location":"changelog/#020-2023-08-25","title":"0.2.0 (2023-08-25)","text":"<ul> <li>Improve GitHub workflow name</li> <li>Get rid of DjangoObjectActions and implement default django admin     action instead (Maybe later we can extend this)</li> <li>Use mixins.BaseExportMixin, mixins.BaseImportMixin and     admin.ImportExportMixinBase from original package for celery admin     mixins</li> <li>Use admin/import_export/ templates instead of copies in     admin/import_export_extensions/</li> <li>Small improvements:</li> <li>Fix static folder name</li> <li>Fix invoke command to run celery</li> <li>Fix progress bar widget</li> <li>Rename filter_class to filterset_class</li> <li>Add cancel_job action for exporting</li> </ul>"},{"location":"changelog/#014-2023-05-22","title":"0.1.4 (2023-05-22)","text":"<ul> <li>Add coverage badge</li> </ul>"},{"location":"changelog/#013-2023-05-15","title":"0.1.3 (2023-05-15)","text":"<ul> <li>Migrate from <code>setup.py</code> and <code>setup.cfg</code> to <code>pyproject.toml</code></li> </ul>"},{"location":"changelog/#012-2023-05-12","title":"0.1.2 (2023-05-12)","text":"<ul> <li>Add support for <code>STORAGES</code> settings variable</li> </ul>"},{"location":"changelog/#011-2023-04-27","title":"0.1.1 (2023-04-27)","text":"<ul> <li>Add package description</li> <li>Add configuration file for read-the-docs service</li> </ul>"},{"location":"changelog/#010-2023-04-01","title":"0.1.0 (2023-04-01)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/saritasa-nest/django-import-export-extensions/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Any details about your local setup that might be helpful in     troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted\\</code>is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p><code>django-import-export-extensions</code> could always use more documentation, whether as part of the official <code>django-import-export-extensions</code> docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/saritasa-nest/django-import-export-extensions/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to     implement.</li> <li>Remember that this is a volunteer-driven project, and that     contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started","text":"<p>Ready to contribute? Here's how to set up <code>django-import-export-extensions</code> for local development.</p> <ol> <li> <p>Fork the django-import-export-extensions repo on     GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:your_name_here/django-import-export-extensions.git\n</code></pre> </li> <li> <p>Setup virtual environment:</p> <p>Using uv:</p> <pre><code>uv venv --python 3.14 --prompt django-import-export-extensions --seed\npoetry config virtualenvs.in-project true\nsource .venv/bin/activate &amp;&amp; poetry install\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you\\'re done making changes, check that your changes pass     linters and the tests:</p> <pre><code>inv pre-commit.run-hooks\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#starting-test-project","title":"Starting test project","text":"<p>To check your changes, you can run test_project:</p> <ol> <li> <p>Set up aliases for docker hosts in <code>/etc/hosts</code>:</p> <pre><code>inv ci.prepare\n</code></pre> <p>or specify values required for database and redis in the <code>.env</code> file. Example:</p> .env<pre><code>DB_HOST=localhost\nREDIS_HOST=localhost\n</code></pre> </li> <li> <p>Run the project and go to <code>localhost:8000</code> page in browser to check whether it was started:</p> <pre><code>inv django.run\n</code></pre> </li> </ol> <p>Note</p> <p>To run import/export in background, change CELERY_TASK_ALWAYS_EAGER to <code>False</code> and start celery with:</p> <pre><code>inv celery.run\n</code></pre>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.   Put your new functionality into a function with a docstring, and add   the feature to the list in README.md.</li> <li>The pull request should work for each supported Python version, and   for PyPy. Check github actions status, verify that all checks have   been passed.</li> </ol>"},{"location":"extensions/","title":"Extensions","text":"<p>This package is an extension of the original <code>django-import-export</code>, so for more information on the import/export process and advanced resource usage, refer the official django-import-export documentation.</p> <p>The following section describes the features added by this package.</p>"},{"location":"extensions/#importjobexportjob-models","title":"ImportJob/ExportJob models","text":"<p><code>django-import-export-extensions</code> provides the <code>ImportJob</code> and <code>ExportJob</code> models to store all information related to the import/export process. Additionally, these models are involved in the background import/export tasks.</p> <p>The job models are already registered in Django Admin and come with custom forms that display all relevant job information, including the current import/export status.</p> <p></p> <p><code>ImportJob</code>/<code>ExportJob</code> models contain useful properties and methods for managing the import/export process. To learn more, see the Models API documentation.</p>"},{"location":"extensions/#celery-admin-mixins","title":"Celery admin mixins","text":"<p>The admin mixins have been completely rewritten, although they still inherit from the base mixins: <code>mixins.BaseImportMixin</code>, <code>mixins.BaseExportMixin</code>, and <code>admin.ImportExportMixinBase</code>. The new Celery admin mixins add pages for displaying import/export status and use custom templates for both the status and results pages.</p> <p>After starting the import/export process, you will be redirected to the status page. Once the import/export is complete, you will then be redirected to the results page.</p> <p></p>"},{"location":"extensions/#viewsets","title":"ViewSets","text":"<p>The <code>ImportJobViewSet</code> and <code>ExportJobViewSet</code> viewsets make it easy to implement import/export functionality via API. To use them, simply create a custom class and set the <code>resource_class</code> attribute:</p> api/views.py<pre><code>from import_export_extensions.api import views as import_export_views\nfrom . import resources\n\n\nclass BandImportViewSet(import_export_views.ImportJobViewSet):\n    resource_class = resources.BandResource\n\n\nclass BandExportViewSet(import_export_views.ExportJobViewSet):\n    resource_class = resources.BandResource\n</code></pre> api/urls.py<pre><code>from rest_framework.routers import DefaultRouter\nfrom .api import views\n\nband_import_export_router = DefaultRouter()\nband_import_export_router.register(\n    \"import-band\",\n    views.BandImportViewSet,\n    basename=\"import-band\",\n)\nband_import_export_router.register(\n    \"export-band\",\n    views.BandExportViewSet,\n    basename=\"export-band\",\n)\n\nurlpatterns = band_import_export_router.urls\n</code></pre> <p>By default, all import/export jobs for the set <code>resource_class</code> will be available, but you can override the <code>get_queryset</code> method to customize this behavior. Additionally, you can override the <code>get_resource_kwargs</code> method to provide custom values in the resource class (e.g., for the start action).</p> <p>These viewsets provide all the methods required for the full import/export workflow: start, details, confirm, cancel, and list actions. There is also integration with drf-spectacular. If you have it installed, you can view the generated OpenAPI UI for these viewsets.</p> <p></p>"},{"location":"extensions/#filters","title":"Filters","text":"<p>The <code>CeleryResource</code> and <code>CeleryModelResource</code> classes also support django-filter to filter the queryset for export. To use this feature, set the <code>filterset_class</code> attribute on your resource class and pass filter parameters as the <code>filter_kwargs</code> argument to the resource:</p> api/filters.py<pre><code>from django_filters import rest_framework as filters\n\nfrom . import models\n\n\nclass BandFilterSet(filters.FilterSet):\n\n    class Meta:\n        model = models.Band\n        fields = [\n            \"id\",\n            \"title\",\n        ]\n</code></pre> resources.py<pre><code>from import_export_extensions import resources\nfrom . import filters\nfrom . import models\n\n\nclass BandResource(resources.CeleryModelResource):\n\n    filterset_class = filters.BandFilterSet\n\n    class Meta:\n        model = models.Band\n        fields = [\n            \"id\",\n            \"title\",\n        ]\n</code></pre> <p>If <code>filterset_class</code> is set for your resource, you can pass <code>filter_kwargs</code> to filter export queryset:</p> <pre><code>&gt;&gt;&gt; from .resources import BandResource\n&gt;&gt;&gt; from .models import Band\n&gt;&gt;&gt; Band.objects.bulk_create([Band(title=title) for title in \"ABC\"])\n&gt;&gt;&gt; BandResource().get_queryset().count()\n3\n&gt;&gt;&gt; filter_kwargs = {\"title\": \"A\"}\n&gt;&gt;&gt; band_resource_with_filters = BandResource(filter_kwargs=filter_kwargs)\n&gt;&gt;&gt; band_resource_with_filters.get_queryset().count()\n1\n</code></pre> <p>Pass <code>filter_kwargs</code> in <code>resource_kwargs</code> argument to create <code>ExportJob</code> with filtered queryset:</p> <pre><code>&gt;&gt;&gt; export_job = ExportJob.objects.create(\n        resource_path=BandResource.class_path,\n        file_format_path=file_format_path,\n        resource_kwargs={\"filter_kwargs\": filter_kwargs},\n    )\n&gt;&gt;&gt; export_job.refresh_from_db()\n&gt;&gt;&gt; len(export_job.result)\n1\n</code></pre> <p>Since we are using the Django REST Framework filter set, the <code>ExportJobViewSet</code> also supports it. It automatically uses the filter set defined in the <code>resource_class</code>. You can see that the start action expects query parameters for filtering:</p> <p></p>"},{"location":"extensions/#force-import","title":"Force import","text":"<p>This package includes a \"force import\" feature. When enabled, rows with errors will be skipped, and the remaining rows will be processed.</p>"},{"location":"extensions/#admin-page","title":"Admin page","text":"<p>This functionality available in admin:</p> <p></p> <p>If any rows contain errors, they will be reported during the parse/import stage:</p> <p></p>"},{"location":"extensions/#api","title":"API","text":"<p>In the API, there are two additional fields: <code>force_import</code> and <code>skip_parse_step</code>.</p> <ul> <li> <p><code>force_import</code> - Allows you to skip rows with errors.</p> </li> <li> <p><code>skip_parse_step</code> - Enables you to run the import task immediately, without needing to call the <code>confirm</code> endpoint.</p> </li> </ul> <p></p>"},{"location":"extensions/#widgets","title":"Widgets","text":"<p>This package also provides additional widgets for some types of data.</p>"},{"location":"extensions/#filewidget","title":"FileWidget","text":"<p>Working with file fields is a common task. The <code>FileWidget</code> allows you to import/export files, including links to external resources, and saves via picked <code>STORAGE</code>. This widget loads a file from a URL into the media directory and correctly renders the link for export. It also supports the <code>AWS_STORAGE_BUCKET_NAME</code> setting.</p>"},{"location":"extensions/#intermediatemanytomanywidget","title":"IntermediateManyToManyWidget","text":"<p><code>IntermediateManyToManyWidget</code> allows to import/export objects with related items. Default M2M widget store just IDs of related objects. With intermediate widget additional data may be stored. Should be used with <code>IntermediateManyToManyField</code>.</p> <p>The <code>IntermediateManyToManyWidget</code> is an advanced widget that allows you to import/export objects with related items in a Many-to-Many relationship, while also supporting additional data beyond just the relationship IDs. Unlike the default M2M widget, which only stores the IDs of related objects, the <code>IntermediateManyToManyWidget</code> enables you to store additional information for each related object, making it more flexible for use cases where extra attributes or fields need to be saved alongside the relationship.</p> <p>This widget is designed to be used with the <code>IntermediateManyToManyField</code> in your model.</p> <p>Usage:</p> resources.py<pre><code>class ArtistResourceWithM2M(CeleryModelResource):\n    \"\"\"Artist resource with Many2Many field.\"\"\"\n\n    bands = IntermediateManyToManyField(\n        attribute=\"bands\",\n        column_name=\"Bands he played in\",\n        widget=IntermediateManyToManyWidget(\n            rem_model=Band,\n            rem_field=\"title\",\n            extra_fields=[\"date_joined\"],\n            instance_separator=\";\",\n        ),\n    )\n\n    class Meta:\n        model = Artist\n        clean_model_instances = True\n        fields = [\n            \"id\",\n            \"name\",\n            \"bands\",\n            \"instrument\",\n        ]\n\n    def get_queryset(self):\n        \"\"\"Reduce DB queries number.\"\"\"\n        return Artist.objects.all().prefetch_related(\n            \"membership_set__band\",\n            \"bands\",\n        )\n</code></pre>"},{"location":"extensions/#result-resultxlsx","title":"Result (result.xlsx)","text":"id name Bands he played in instrument 1 Rachel Schmidt Walter-Hodges:1971-09-22;Ortiz-Hughes:2018-02-02 1"},{"location":"extensions/#fields","title":"Fields","text":""},{"location":"extensions/#intermediatemanytomanyfield","title":"IntermediateManyToManyField","text":"<p>This is resource field for M2M with custom <code>through</code> model.</p> <p>By default, <code>django-import-export</code> set up object attributes using <code>setattr(obj, attribute_name, value)</code>, where <code>value</code> is <code>QuerySet</code> of related model objects. But django forbid this when <code>ManyToManyField</code> used with custom <code>through</code> model.</p> <p>This field expects be used with custom <code>IntermediateManyToManyWidget</code> widget that return not simple value, but dict with intermediate model attributes.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p><code>django-import-export-extensions</code> is based on <code>django-import-export</code> package, so it follows a similar workflow and interfaces. If you are already familiar with the original package, you can refer to the Migrate from original django-import-export package section to start using background import/export.</p> <p>You can also consult the django-import-export documentation to learn how to work with import and export features.</p> <p>There are simple examples to quickly get import/export functionality.</p>"},{"location":"getting_started/#django-model-for-tests","title":"Django Model for tests","text":"<p>There is simple Django model from test app that we gonna use in the examples above.</p> <pre><code>from django.db import models\n\n\nclass Band(models.Model):\n\n    title = models.CharField(\n        max_length=100,\n    )\n\n    class Meta:\n        verbose_name = _(\"Band\")\n        verbose_name_plural = _(\"Bands\")\n\n    def __str__(self) -&gt; str:\n        return self.title\n</code></pre>"},{"location":"getting_started/#resources","title":"Resources","text":"<p>The resource class is a core of import/export. It is similar to Django forms but provides methods for converting data between files and objects.</p> <p><code>django-import-export-extensions</code> provides two key classes: <code>CeleryResource</code> and <code>CeleryModelResource</code>. Below is an example of a simple model resource:</p> <pre><code>from import_export_extensions.resources import CeleryModelResource\n\n\nclass BandResource(CeleryModelResource):\n    \"\"\"Resource for `Band` model.\"\"\"\n\n    class Meta:\n        model = Band\n        fields = [\n            \"id\",\n            \"title\",\n        ]\n</code></pre> <p>This resource class allows you to import/export data just like the original package. However, to perform imports/exports in the background, you need to create <code>ImportJob</code> and <code>ExportJob</code> objects.</p> <p>The resource classes have been modified to interact with Celery, but the overall workflow remains the same. For more details, refer to the Resources and Import data workflow sections of the base package documentation.</p>"},{"location":"getting_started/#job-models","title":"Job Models","text":"<p>The package provides the <code>ImportJob</code> and <code>ExportJob</code> models, which are at the core of background import/export functionality. These models store the parameters and results of the import/export process. Once you create an instance of one of these classes, the Celery task is triggered, and the import/export process begins.</p> <p>Example of creation:</p> <pre><code>from import_export_extensions import models\nfrom . import resources\n\nfile_format_path = \"import_export.formats.base_formats.CSV\"\nimport_file = \"files/import_file.csv\"\n\n# Start import job\nimport_job = models.ImportJob.objects.create(\n    resource_path=resources.BandResource.class_path,\n    data_file=import_file,\n    resource_kwargs={},\n)\n\n# Start export job\nexport_job = models.ExportJob.objects.create(\n    resource_path=resources.BandResource.class_path,\n    file_format_path=file_format_path,\n    resource_kwargs={}\n)\n\nprint(import_job.import_status, export_job.export_status)  # CREATED CREATED\n</code></pre> <p>These models are also registered in the Django Admin, allowing you to view all information about the created jobs directly from the admin interface.</p>"},{"location":"getting_started/#signals","title":"Signals","text":"<p>The package provides signals <code>export_job_failed</code> and <code>import_job_failed</code>. You can use them to handle errors that happened during job.</p> <p>Example</p> signals.py<pre><code>import logging\n\nfrom django import dispatch\n\nfrom import_export_extensions.models.core import BaseJob\nfrom import_export_extensions.signals import (\n    export_job_failed,\n    import_job_failed,\n)\n\n\n@dispatch.receiver(export_job_failed)\n@dispatch.receiver(import_job_failed)\ndef job_error_hook(\n    sender,\n    instance: BaseJob,\n    error_message: str,\n    traceback: str,\n    exception: Exception | None,\n    **kwargs,\n):\n    \"\"\"Present an example of job error hook.\"\"\"\n    logging.getLogger(__file__).warning(f\"{instance}, {error_message}\")\n</code></pre>"},{"location":"getting_started/#admin-models","title":"Admin models","text":"<p>To perform import/export operations using Celery through Django Admin, use the <code>CeleryImportExportMixin</code> in your admin model and set the <code>resource_classes</code> class attribute.</p> admin.py<pre><code>from import_export_extensions.admin import CeleryImportExportMixin\nfrom . import resources\nfrom . import models\n\n\n@admin.register(models.Band)\nclass BandAdmin(CeleryImportExportMixin, admin.ModelAdmin):\n    \"\"\"Admin for `Band` model with import export functionality.\"\"\"\n    list_display = (\n        \"title\",\n    )\n    resource_classes = [resources.BandResource]\n</code></pre> <p>There are also the <code>CeleryImportAdminMixin</code> and <code>CeleryExportAdminMixin</code> mixins available if you need to perform only one operation (import or export) in the admin. All of these mixins add a <code>status page</code>, where you can monitor the progress of the import/export process:</p> <p></p>"},{"location":"getting_started/#importexport-api","title":"Import/Export API","text":"<p>The <code>api.views.ExportJobViewSet</code> and <code>api.views.ImportJobViewSet</code> are provided to create the corresponding viewsets for the resource.</p> views.py<pre><code>from import_export_extensions.api import views\nfrom . import resources\n\n\nclass BandExportViewSet(views.ExportJobViewSet):\n    \"\"\"Simple ViewSet for exporting `Band` model.\"\"\"\n    resource_class = resources.BandResource\n\n\nclass BandImportViewSet(views.ImportJobViewSet):\n    \"\"\"Simple ViewSet for importing `Band` model.\"\"\"\n    resource_class = resources.BandResource\n</code></pre> <p>These viewsets provide the following actions to manage <code>ImportJob</code>/<code>ExportJob</code> objects:</p> <ul> <li><code>list</code> - Returns a list of jobs for the <code>resource_class</code> set in     ViewSet</li> <li><code>retrieve</code> - Returns details of a job based on the provided ID</li> <li><code>start</code> - Creates a job object and starts the import/export process</li> <li><code>cancel</code> - Stops the import/export process and sets the job\\'s     status to <code>CANCELLED</code>.</li> <li><code>confirm</code> - Confirms the import after the parse stage. This action     is available only in <code>ImportJobViewSet</code>.</li> </ul> <p>Additionally, there is <code>drf_spectacular</code> integration. If you have this package configured, the OpenAPI specification will be available.</p> <p></p>"},{"location":"getting_started/#importexport-api-actions-mixins","title":"Import/Export API actions mixins","text":"<p>Alternatively you can use <code>api.mixins.ExportStartActionMixin</code> and <code>api.mixins.ImportStartActionMixin</code> to add to your current viewsets ability to create import/export jobs. You would also need to use <code>api.views.BaseExportJobViewSet</code> or <code>BaseExportJobForUsersViewSet</code> and <code>api.views.BaseImportJobViewSet</code> or <code>BaseImportJobForUsersViewSet</code> to setup endpoints to be able to:</p> <ul> <li><code>list</code> - Returns a list of jobs for the <code>resource_class</code> set in     ViewSet.</li> <li><code>retrieve</code> - Returns details of a job based on the provided ID.</li> <li><code>cancel</code> - Stops the import/export process and sets the job\\'s     status to <code>CANCELLED</code>.</li> <li><code>confirm</code> - Confirms the import after the parse stage. This action     is available only in import jobs.</li> </ul> <p></p>"},{"location":"installation/","title":"Installation and configuration","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install <code>django-import-export-extensions</code>, run the following command in your terminal:</p> <p>Using pip:</p> <pre><code>pip install django-import-export-extensions\n</code></pre> <p>Using uv:</p> <pre><code>uv pip install django-import-export-extensions\n</code></pre> <p>Using poetry:</p> <pre><code>poetry add django-import-export-extensions\n</code></pre> <p>This is the preferred installation method, as it will always install the most recent stable release of <code>django-import-export-extensions</code>.</p> <p>Next, add <code>import_export</code> and <code>import_export_extensions</code> to your <code>INSTALLED_APPS</code> setting:</p> settings.py<pre><code>INSTALLED_APPS = [\n    ...\n    \"import_export\",\n    \"import_export_extensions\",\n]\n</code></pre> <p>Finally, run the <code>migrate</code> and <code>collectstatic</code> commands:</p> <ul> <li><code>migrate</code>: Creates the ImportJob and ExportJob models.</li> <li><code>collectstatic</code>: Allows Django to collect static files for use in     the admin interface.</li> </ul> <pre><code>python manage.py migrate\npython manage.py collectstatic\n</code></pre>"},{"location":"installation/#celery","title":"Celery","text":"<p>To use background import/export, you need to set up Celery. Once Celery is set up, no additional configuration is required.</p>"},{"location":"installation/#settings","title":"Settings","text":"<p>You can configure the following settings in your Django settings file:</p>"},{"location":"installation/#import_export_max_dataset_rows","title":"<code>IMPORT_EXPORT_MAX_DATASET_ROWS</code>","text":"<p>Defines the maximum number of rows allowed in a file for import, helping to avoid memory overflow. The default value is 100,000. If the file exceeds this limit, a <code>ValueError</code> exception will be raised during the import process.</p>"},{"location":"installation/#mime_types_map","title":"<code>MIME_TYPES_MAP</code>","text":"<p>Mapping file extensions to mime types to import files. By default, it uses the mimetypes.types_map from Python\\'s mimetypes module.</p>"},{"location":"installation/#status_update_row_count","title":"<code>STATUS_UPDATE_ROW_COUNT</code>","text":"<p>Defines the number of rows after import/export of which the task status is updated. This helps to increase the speed of import/export. The default value is 100. This parameter can be specified separately for each resource by adding <code>status_update_row_count</code> to its <code>Meta</code>.</p>"},{"location":"installation/#drf_export_django_filters_backend","title":"<code>DRF_EXPORT_DJANGO_FILTERS_BACKEND</code>","text":"<p>Specifies filter backend class for <code>django-filters</code> in export action. Default: <code>django_filters.rest_framework.DjangoFilterBackend</code></p>"},{"location":"installation/#drf_export_ordering_backend","title":"<code>DRF_EXPORT_ORDERING_BACKEND</code>","text":"<p>Specifies filter backend class for <code>ordering</code> in export action. Default: <code>rest_framework.filters.OrderingFilter</code></p>"},{"location":"installation/#settings-from-django-import-export","title":"Settings from django-import-export","text":"<p>Additionally, the package supports settings from the original django-import-export package. For full details on these settings, refer to the official documentation.</p> <p>Note: The only setting that does not affect functionality in this package is <code>IMPORT_EXPORT_TMP_STORAGE_CLASS</code>, as the storage is not used in the implementation of <code>CeleryImportAdminMixin</code>.</p>"},{"location":"installation/#picking-storage","title":"Picking storage","text":"<p>To use different storage for import/export jobs you can use STORAGES from Django.</p> settings.py<pre><code>STORAGES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.files.storage.filesystem.FileSystemStorage\",\n    },\n    \"staticfiles\": {\n        \"BACKEND\": \"django.contrib.staticfiles.storage.StaticFilesStorage\",\n    },\n    # Use this to specify custom storage for package\n    \"django_import_export_extensions\": {\n        \"BACKEND\": \"django.core.files.storage.filesystem.FileSystemStorage\",\n    },\n}\n</code></pre>"},{"location":"migrate_from_original_import_export/","title":"Migrate from original django-import-export package","text":"<p>If you're already using <code>django-import-export</code> and want to take advantage of <code>django-import-export-extensions</code> for background import/export, the transition is simple. First, install the package by following the the installation guide Installation and configuration. Then, all you need to do is update the base classes for your resource and admin models.</p>"},{"location":"migrate_from_original_import_export/#migrate-resources","title":"Migrate resources","text":"<p>To enable import/export via Celery, simply replace the base resource classes from the original package with <code>CeleryResource</code> or <code>CeleryModelResource</code> from <code>django-import-export-extensions</code>:</p> <pre><code>- from import_export import resources\n+ from import_export_extensions import resources\n\nclass SimpleResource(\n-     resources.Resource,\n+     resources.CeleryResource,\n):\n    \"\"\"Simple resource.\"\"\"\n\n\nclass BookResource(\n-    resources.ModelResource,\n+    resources.CeleryModelResource,\n):\n    \"\"\"Resource class for `Book` model.\"\"\"\n\n    class Meta:\n        model = Book\n</code></pre>"},{"location":"migrate_from_original_import_export/#migrate-admin-models","title":"Migrate admin models","text":"<p>Then you also need to change admin mixins to use celery import/export via Django Admin:</p> <pre><code>- from import_export.admin import ImportExportModelAdmin\n+ from import_export_extensions.admin import CeleryImportExportMixin\n\nfrom . import resources\n\nclass BookAdmin(\n-    ImportExportModelAdmin,\n+    CeleryImportExportMixin,\n+    admin.ModelAdmin,\n):\n    \"\"\"Resource class for `Book` model.\"\"\"\n\n    resource_classes = (\n        resources.BookResource,\n    )\n</code></pre> <p>If you only need import (or export) functionality, you can use the <code>CeleryImportAdminMixin</code> (or <code>CeleryExportAdminMixin</code>) instead of the <code>CeleryImportExportMixin</code>.</p>"},{"location":"migrate_from_original_import_export/#migrate-custom-importexport","title":"Migrate custom import/export","text":"<p>Background import/export is implemented using the <code>ImportJob</code> and <code>ExportJob</code> models. As a result, calling the simple <code>resource.export()</code> will not trigger a Celery task --- it behaves exactly like the original <code>Resource.export()</code> method. To initiate background import/export, you need to create instances of the import/export job:</p> <pre><code>&gt;&gt;&gt; from .resources import BandResource\n&gt;&gt;&gt; from import_export.formats import base_formats\n&gt;&gt;&gt; from import_export_extensions.models import ExportJob\n&gt;&gt;&gt; file_format = base_formats.CSV\n&gt;&gt;&gt; file_format_path = f\"{file_format.__module__}.{file_format.__name__}\"\n&gt;&gt;&gt; export_job = ExportJob.objects.create(\n        resource_path=BandResource.class_path,\n        file_format_path=file_format_path\n    )\n&gt;&gt;&gt; export_job.export_status\n'CREATED'\n</code></pre> <p>You can check the current status of the job using the <code>export_status</code> (or <code>import_status</code>) property of the model. Additionally, the <code>progress</code> property provides information about the total number of rows and the number of rows that have been completed.</p> <pre><code>&gt;&gt;&gt; export_job.refresh_from_db()\n&gt;&gt;&gt; export_job.export_status\n'EXPORTING'\n&gt;&gt;&gt; export_job.progress\n{'state': 'EXPORTING', 'info': {'current': 53, 'total': 100}}\n&gt;&gt;&gt; export_job.refresh_from_db()\n&gt;&gt;&gt; export_job.export_status\n'EXPORTED'\n&gt;&gt;&gt; export_job.data_file.path\n'../media/import_export_extensions/export/3dfb7510-5593-4dc6-9d7d-bbd907cd3eb6/Artists-2020-02-22.csv'\n</code></pre>"},{"location":"migrate_from_original_import_export/#other-configuration","title":"Other configuration","text":"<p>You may need to configure MEDIA_URL in your project settings, otherwise you may see a 404 error when attempting to download exported files.</p>"},{"location":"recipes_and_integration_tips/","title":"Recipes &amp; Integration Tips","text":""},{"location":"recipes_and_integration_tips/#django-tenants-integration","title":"django-tenants integration","text":"<p>You might need additional changes for integration with django-tenants.</p> <p>Change connection schema if it was provided in admin.</p> <pre><code>from django.db import connection\n\nclass MyModelResource(CeleryModelResource):\n    def __init__(self, *args, **kwargs):\n\n        # If schema_name is provided, switch db schema\n        if \"schema_name\" in kwargs:\n            connection.set_schema(kwargs[\"schema_name\"])\n\n        super().__init__(*args, **kwargs)\n</code></pre> <p>Pass schema for resource.</p> <pre><code>@admin.register(MyModel)\nclass MyModelAdmin(CeleryImportExportMixin, admin.ModelAdmin):\n    resource_classes = [MyModelResource]\n\n    def get_resource_kwargs(self, request, *args, **kwargs):\n\n        # Pass schema to job\n        kwargs[\"schema_name\"] = request.tenant.schema_name\n\n        return super().get_resource_kwargs(request, *args, **kwargs)\n</code></pre>"},{"location":"reference/admin/","title":"Admin","text":""},{"location":"reference/admin/#import_export_extensions.admin.model_admins.export_job_admin.ExportJobAdmin","title":"<code>ExportJobAdmin</code>","text":"<p>               Bases: <code>BaseImportExportJobAdminMixin</code>, <code>ModelAdmin</code></p> <p>Admin class for debugging ExportJob.</p> Source code in <code>import_export_extensions/admin/model_admins/export_job_admin.py</code> <pre><code>@admin.register(models.ExportJob)\nclass ExportJobAdmin(\n    mixins.BaseImportExportJobAdminMixin,\n    admin.ModelAdmin,\n):\n    \"\"\"Admin class for debugging ExportJob.\"\"\"\n\n    form = forms.ExportJobAdminForm\n    exclude = (\"result\",)\n    list_display = (\n        \"id\",\n        \"export_status\",\n        \"_model\",\n        \"created_by\",\n        \"created\",\n        \"export_started\",\n        \"export_finished\",\n    )\n    list_display_links = (\n        \"id\",\n        \"export_status\",\n        \"_model\",\n    )\n    date_hierarchy = \"created\"\n    export_job_model = models.ExportJob\n    list_filter = (\"export_status\",)\n    list_select_related = (\"created_by\",)\n    actions = (\n        \"cancel_jobs\",\n    )\n    readonly_fields = (\n        \"export_status\",\n        \"traceback\",\n        \"file_format_path\",\n        \"created\",\n        \"export_started\",\n        \"export_finished\",\n        \"error_message\",\n        \"_model\",\n        \"created_by\",\n        \"resource_path\",\n        \"data_file\",\n        \"resource_kwargs\",\n    )\n\n    def get_urls(self) -&gt; list[URLPattern]:\n        \"\"\"Add url to get current export job progress in JSON representation.\n\n        /admin/import_export_extensions/exportjob/&lt;job_id&gt;/progress/\n\n        \"\"\"\n        urls = super().get_urls()\n        export_urls = [\n            re_path(\n                route=r\"^(?P&lt;job_id&gt;\\d+)/progress/$\",\n                view=self.admin_site.admin_view(self.export_job_progress_view),\n                name=\"export_job_progress\",\n            ),\n        ]\n        return export_urls + urls\n\n    def export_job_progress_view(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n        **kwargs,\n    ) -&gt; JsonResponse:\n        \"\"\"View to return `ExportJob` status as JSON.\n\n        If current status is exporting, view also returns job state\n        and percent of completed work.\n\n        Return:\n            Response: dictionary with status (optionally, state and percent).\n\n        \"\"\"\n        try:\n            job: models.ExportJob = self.export_job_model.objects.get(\n                id=job_id,\n            )\n        except self.export_job_model.DoesNotExist as error:\n            return JsonResponse(\n                {\"validation_error\": error.args[0]},\n                status=http.HTTPStatus.NOT_FOUND,\n            )\n\n        response_data = {\"status\": job.export_status.title()}\n\n        if job.export_status != models.ExportJob.ExportStatus.EXPORTING:\n            return JsonResponse(response_data)\n\n        percent = 0\n        total = 0\n        current = 0\n        job_progress = job.progress\n        progress_info = job_progress[\"info\"]\n\n        if progress_info and progress_info[\"total\"]:\n            total = progress_info[\"total\"]\n            current = progress_info[\"current\"]\n            percent = int(100 / total * current)\n\n        response_data.update(\n            state=job_progress[\"state\"],\n            percent=percent,\n            total=total,\n            current=current,\n        )\n        return JsonResponse(response_data)\n\n    def get_fieldsets(\n        self,\n        request: WSGIRequest,\n        obj: models.ExportJob,\n    ) -&gt; list[tuple[str, dict[str, typing.Any]]]:\n        \"\"\"Get fieldsets depending on object status.\"\"\"\n        status = (\n            _(\"Status\"),\n            {\n                \"fields\": (\n                    \"export_status\",\n                    \"_model\",\n                    \"created_by\",\n                    \"created\",\n                    \"export_started\",\n                    \"export_finished\",\n                ),\n            },\n        )\n        progress = (\n            _(\"Status\"),\n            {\n                \"fields\": (\n                    \"export_status\",\n                    \"export_progressbar\",\n                ),\n            },\n        )\n        export_params = (\n            _(\"Export params\"),\n            {\n                \"fields\": (\n                    \"resource_path\",\n                    \"resource_kwargs\",\n                    \"file_format_path\",\n                ),\n                \"classes\": (\"collapse\",),\n            },\n        )\n        traceback_fields = (\n            _(\"Traceback\"),\n            {\n                \"fields\": (\n                    \"error_message\",\n                    \"traceback\",\n                ),\n            },\n        )\n        result = (\n            _(\"Export results\"),\n            {\n                \"fields\": (\"data_file\",),\n            },\n        )\n\n        if obj.export_status == models.ExportJob.ExportStatus.CREATED:\n            return [status, export_params]\n\n        if obj.export_status == models.ExportJob.ExportStatus.EXPORTED:\n            return [status, result, export_params]\n\n        if obj.export_status == models.ExportJob.ExportStatus.EXPORTING:\n            return [progress, export_params]\n\n        return [status, traceback_fields, export_params]\n\n    @admin.action(description=\"Cancel selected jobs\")\n    def cancel_jobs(self, request: WSGIRequest, queryset: QuerySet) -&gt; None:\n        \"\"\"Admin action for cancelling data export.\"\"\"\n        for job in queryset:\n            try:\n                job.cancel_export()\n                self.message_user(\n                    request,\n                    _(f\"Export of {job} canceled\"),\n                    messages.SUCCESS,\n                )\n            except ValueError as error:\n                self.message_user(request, str(error), messages.ERROR)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.export_job_admin.ExportJobAdmin.cancel_jobs","title":"<code>cancel_jobs(request, queryset)</code>","text":"<p>Admin action for cancelling data export.</p> Source code in <code>import_export_extensions/admin/model_admins/export_job_admin.py</code> <pre><code>@admin.action(description=\"Cancel selected jobs\")\ndef cancel_jobs(self, request: WSGIRequest, queryset: QuerySet) -&gt; None:\n    \"\"\"Admin action for cancelling data export.\"\"\"\n    for job in queryset:\n        try:\n            job.cancel_export()\n            self.message_user(\n                request,\n                _(f\"Export of {job} canceled\"),\n                messages.SUCCESS,\n            )\n        except ValueError as error:\n            self.message_user(request, str(error), messages.ERROR)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.export_job_admin.ExportJobAdmin.export_job_progress_view","title":"<code>export_job_progress_view(request, job_id, **kwargs)</code>","text":"<p>View to return <code>ExportJob</code> status as JSON.</p> <p>If current status is exporting, view also returns job state and percent of completed work.</p> Return <p>Response: dictionary with status (optionally, state and percent).</p> Source code in <code>import_export_extensions/admin/model_admins/export_job_admin.py</code> <pre><code>def export_job_progress_view(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n    **kwargs,\n) -&gt; JsonResponse:\n    \"\"\"View to return `ExportJob` status as JSON.\n\n    If current status is exporting, view also returns job state\n    and percent of completed work.\n\n    Return:\n        Response: dictionary with status (optionally, state and percent).\n\n    \"\"\"\n    try:\n        job: models.ExportJob = self.export_job_model.objects.get(\n            id=job_id,\n        )\n    except self.export_job_model.DoesNotExist as error:\n        return JsonResponse(\n            {\"validation_error\": error.args[0]},\n            status=http.HTTPStatus.NOT_FOUND,\n        )\n\n    response_data = {\"status\": job.export_status.title()}\n\n    if job.export_status != models.ExportJob.ExportStatus.EXPORTING:\n        return JsonResponse(response_data)\n\n    percent = 0\n    total = 0\n    current = 0\n    job_progress = job.progress\n    progress_info = job_progress[\"info\"]\n\n    if progress_info and progress_info[\"total\"]:\n        total = progress_info[\"total\"]\n        current = progress_info[\"current\"]\n        percent = int(100 / total * current)\n\n    response_data.update(\n        state=job_progress[\"state\"],\n        percent=percent,\n        total=total,\n        current=current,\n    )\n    return JsonResponse(response_data)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.export_job_admin.ExportJobAdmin.get_fieldsets","title":"<code>get_fieldsets(request, obj)</code>","text":"<p>Get fieldsets depending on object status.</p> Source code in <code>import_export_extensions/admin/model_admins/export_job_admin.py</code> <pre><code>def get_fieldsets(\n    self,\n    request: WSGIRequest,\n    obj: models.ExportJob,\n) -&gt; list[tuple[str, dict[str, typing.Any]]]:\n    \"\"\"Get fieldsets depending on object status.\"\"\"\n    status = (\n        _(\"Status\"),\n        {\n            \"fields\": (\n                \"export_status\",\n                \"_model\",\n                \"created_by\",\n                \"created\",\n                \"export_started\",\n                \"export_finished\",\n            ),\n        },\n    )\n    progress = (\n        _(\"Status\"),\n        {\n            \"fields\": (\n                \"export_status\",\n                \"export_progressbar\",\n            ),\n        },\n    )\n    export_params = (\n        _(\"Export params\"),\n        {\n            \"fields\": (\n                \"resource_path\",\n                \"resource_kwargs\",\n                \"file_format_path\",\n            ),\n            \"classes\": (\"collapse\",),\n        },\n    )\n    traceback_fields = (\n        _(\"Traceback\"),\n        {\n            \"fields\": (\n                \"error_message\",\n                \"traceback\",\n            ),\n        },\n    )\n    result = (\n        _(\"Export results\"),\n        {\n            \"fields\": (\"data_file\",),\n        },\n    )\n\n    if obj.export_status == models.ExportJob.ExportStatus.CREATED:\n        return [status, export_params]\n\n    if obj.export_status == models.ExportJob.ExportStatus.EXPORTED:\n        return [status, result, export_params]\n\n    if obj.export_status == models.ExportJob.ExportStatus.EXPORTING:\n        return [progress, export_params]\n\n    return [status, traceback_fields, export_params]\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.export_job_admin.ExportJobAdmin.get_urls","title":"<code>get_urls()</code>","text":"<p>Add url to get current export job progress in JSON representation.</p> <p>/admin/import_export_extensions/exportjob//progress/ Source code in <code>import_export_extensions/admin/model_admins/export_job_admin.py</code> <pre><code>def get_urls(self) -&gt; list[URLPattern]:\n    \"\"\"Add url to get current export job progress in JSON representation.\n\n    /admin/import_export_extensions/exportjob/&lt;job_id&gt;/progress/\n\n    \"\"\"\n    urls = super().get_urls()\n    export_urls = [\n        re_path(\n            route=r\"^(?P&lt;job_id&gt;\\d+)/progress/$\",\n            view=self.admin_site.admin_view(self.export_job_progress_view),\n            name=\"export_job_progress\",\n        ),\n    ]\n    return export_urls + urls\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin","title":"<code>ImportJobAdmin</code>","text":"<p>               Bases: <code>BaseImportExportJobAdminMixin</code>, <code>ModelAdmin</code></p> <p>Admin class for debugging ImportJob.</p> Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>@admin.register(models.ImportJob)\nclass ImportJobAdmin(\n    mixins.BaseImportExportJobAdminMixin,\n    admin.ModelAdmin,\n):\n    \"\"\"Admin class for debugging ImportJob.\"\"\"\n\n    form = forms.ImportJobAdminForm\n    exclude = (\"result\",)\n    list_display = (\n        \"id\",\n        \"import_status\",\n        \"_model\",\n        \"created_by\",\n        \"created\",\n        \"parse_finished\",\n        \"import_started\",\n        \"import_finished\",\n    )\n    list_display_links = (\n        \"id\",\n        \"import_status\",\n        \"_model\",\n    )\n    date_hierarchy = \"created\"\n    import_job_model = models.ImportJob\n    list_filter = (\"import_status\",)\n    list_select_related = (\"created_by\",)\n    actions = (\n        \"cancel_jobs\",\n        \"confirm_jobs\",\n    )\n    readonly_fields = (\n        \"import_status\",\n        \"_model\",\n        \"created_by\",\n        \"traceback\",\n        \"_show_results\",\n        \"_input_errors\",\n        \"created\",\n        \"parse_finished\",\n        \"import_started\",\n        \"import_finished\",\n        \"resource_path\",\n        \"input_errors_file\",\n        \"data_file\",\n        \"resource_kwargs\",\n    )\n\n    def get_queryset(self, request: WSGIRequest) -&gt; QuerySet:\n        \"\"\"Override `get_queryset`.\n\n        Do not get `result` from db because it can be rather big and is not\n        used in admin.\n\n        \"\"\"\n        return super().get_queryset(request).defer(\"result\")\n\n    def get_urls(self) -&gt; list[URLPattern]:\n        \"\"\"Add url to get current import job progress in JSON representation.\n\n        /admin/import_export_extensions/importjob/&lt;job_id&gt;/progress/\n\n        \"\"\"\n        urls = super().get_urls()\n        import_urls = [\n            re_path(\n                r\"^(?P&lt;job_id&gt;\\d+)/progress/$\",\n                self.admin_site.admin_view(self.import_job_progress_view),\n                name=\"import_job_progress\",\n            ),\n        ]\n        return import_urls + urls\n\n    def import_job_progress_view(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n        **kwargs,\n    ) -&gt; JsonResponse:\n        \"\"\"View to return ``ImportJob`` status as JSON.\n\n        If current status is parsing/importing, view also returns job state\n        and percent of completed work.\n\n        Return:\n            Response: dictionary with status (optionally, state and percent).\n\n        \"\"\"\n        try:\n            job: models.ImportJob = self.import_job_model.objects.get(\n                id=job_id,\n            )\n        except self.import_job_model.DoesNotExist as error:\n            return JsonResponse(\n                {\"validation_error\": error.args[0]},\n                status=http.HTTPStatus.NOT_FOUND,\n            )\n\n        response_data = {\"status\": job.import_status.title()}\n\n        if job.import_status not in models.ImportJob.progress_statuses:\n            return JsonResponse(response_data)\n\n        percent = 0\n        total = 0\n        current = 0\n        job_progress = job.progress\n        progress_info = job_progress[\"info\"]\n\n        if progress_info and progress_info[\"total\"]:\n            total = progress_info[\"total\"]\n            current = progress_info[\"current\"]\n            percent = int(100 / total * current)\n\n        response_data.update(\n            state=job_progress[\"state\"],\n            percent=percent,\n            total=total,\n            current=current,\n        )\n\n        return JsonResponse(response_data)\n\n    def _show_results(\n        self,\n        obj: models.ImportJob,\n    ) -&gt; str:\n        \"\"\"Show results totals.\n\n        Example return value:\n        New: 99\n        Update: 1\n        Delete: 0\n        Skip: 0\n        Error: 0\n\n        \"\"\"\n        result_sections = []\n        for key, value in obj.result.totals.items():\n            status_template = f\"{key.title()}: {value}\"\n            result_sections.append(status_template)\n\n        return \"\\n\".join(result_sections)\n\n    _show_results.short_description = _(\"Parse/Import results\")\n\n    def _input_errors(self, job: models.ImportJob) -&gt; SafeText:\n        \"\"\"Render html with input errors.\"\"\"\n        template = \"admin/import_export_extensions/import_job_results.html\"\n        return render_to_string(\n            template,\n            {\"result\": job.result},\n        )\n\n    _input_errors.short_description = _(\"Import data\")\n    _input_errors.allow_tags = True\n\n    def get_fieldsets(\n        self,\n        request: WSGIRequest,\n        obj: models.ImportJob,\n    ) -&gt; list[tuple[str, dict[str, typing.Any]]]:\n        \"\"\"Get fieldsets depending on object status.\"\"\"\n        status = (\n            _(\"Status\"),\n            {\n                \"fields\": (\n                    \"import_status\",\n                    \"_model\",\n                    \"created_by\",\n                    \"created\",\n                    \"parse_finished\",\n                    \"import_started\",\n                    \"import_finished\",\n                ),\n            },\n        )\n        progress = (\n            _(\"Status\"),\n            {\n                \"fields\": (\n                    \"import_status\",\n                    \"import_progressbar\",\n                ),\n            },\n        )\n        import_params = (\n            _(\"Import params\"),\n            {\n                \"fields\": (\n                    \"data_file\",\n                    \"resource_path\",\n                    \"resource_kwargs\",\n                ),\n                \"classes\": (\"collapse\",),\n            },\n        )\n        traceback_ = (\n            _(\"Traceback\"),\n            {\n                \"fields\": (\"traceback\",),\n            },\n        )\n        result = (\n            _(\"Result totals\"),\n            {\n                \"fields\": (\"_show_results\",),\n                \"classes\": (\"collapse\",),\n            },\n        )\n        data = (\n            _(\"Importing data\"),\n            {\n                \"fields\": (\n                    \"input_errors_file\",\n                    \"_input_errors\",\n                ),\n                \"classes\": (\"collapse\",),\n            },\n        )\n\n        if obj.import_status == models.ImportJob.ImportStatus.CREATED:\n            return [status, import_params]\n\n        if obj.import_status in models.ImportJob.success_statuses:\n            return [status, result, data, import_params]\n\n        if obj.import_status in models.ImportJob.progress_statuses:\n            return [status, progress, import_params]\n\n        return [status, traceback_, import_params]\n\n    @admin.action(description=\"Cancel selected jobs\")\n    def cancel_jobs(self, request: WSGIRequest, queryset: QuerySet) -&gt; None:\n        \"\"\"Admin action for cancelling data import.\"\"\"\n        for job in queryset:\n            try:\n                job.cancel_import()\n                self.message_user(\n                    request,\n                    _(f\"Import of {job} canceled\"),\n                    messages.SUCCESS,\n                )\n            except ValueError as error:\n                self.message_user(request, str(error), messages.ERROR)\n\n    @admin.action(description=\"Confirm selected jobs\")\n    def confirm_jobs(self, request: WSGIRequest, queryset: QuerySet) -&gt; None:\n        \"\"\"Admin action for confirming data import.\"\"\"\n        for job in queryset:\n            try:\n                job.confirm_import()\n                self.message_user(\n                    request,\n                    _(f\"Import of {job} confirmed\"),\n                    messages.SUCCESS,\n                )\n            except ValueError as error:\n                self.message_user(request, str(error), messages.ERROR)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin.cancel_jobs","title":"<code>cancel_jobs(request, queryset)</code>","text":"<p>Admin action for cancelling data import.</p> Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>@admin.action(description=\"Cancel selected jobs\")\ndef cancel_jobs(self, request: WSGIRequest, queryset: QuerySet) -&gt; None:\n    \"\"\"Admin action for cancelling data import.\"\"\"\n    for job in queryset:\n        try:\n            job.cancel_import()\n            self.message_user(\n                request,\n                _(f\"Import of {job} canceled\"),\n                messages.SUCCESS,\n            )\n        except ValueError as error:\n            self.message_user(request, str(error), messages.ERROR)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin.confirm_jobs","title":"<code>confirm_jobs(request, queryset)</code>","text":"<p>Admin action for confirming data import.</p> Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>@admin.action(description=\"Confirm selected jobs\")\ndef confirm_jobs(self, request: WSGIRequest, queryset: QuerySet) -&gt; None:\n    \"\"\"Admin action for confirming data import.\"\"\"\n    for job in queryset:\n        try:\n            job.confirm_import()\n            self.message_user(\n                request,\n                _(f\"Import of {job} confirmed\"),\n                messages.SUCCESS,\n            )\n        except ValueError as error:\n            self.message_user(request, str(error), messages.ERROR)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin.get_fieldsets","title":"<code>get_fieldsets(request, obj)</code>","text":"<p>Get fieldsets depending on object status.</p> Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>def get_fieldsets(\n    self,\n    request: WSGIRequest,\n    obj: models.ImportJob,\n) -&gt; list[tuple[str, dict[str, typing.Any]]]:\n    \"\"\"Get fieldsets depending on object status.\"\"\"\n    status = (\n        _(\"Status\"),\n        {\n            \"fields\": (\n                \"import_status\",\n                \"_model\",\n                \"created_by\",\n                \"created\",\n                \"parse_finished\",\n                \"import_started\",\n                \"import_finished\",\n            ),\n        },\n    )\n    progress = (\n        _(\"Status\"),\n        {\n            \"fields\": (\n                \"import_status\",\n                \"import_progressbar\",\n            ),\n        },\n    )\n    import_params = (\n        _(\"Import params\"),\n        {\n            \"fields\": (\n                \"data_file\",\n                \"resource_path\",\n                \"resource_kwargs\",\n            ),\n            \"classes\": (\"collapse\",),\n        },\n    )\n    traceback_ = (\n        _(\"Traceback\"),\n        {\n            \"fields\": (\"traceback\",),\n        },\n    )\n    result = (\n        _(\"Result totals\"),\n        {\n            \"fields\": (\"_show_results\",),\n            \"classes\": (\"collapse\",),\n        },\n    )\n    data = (\n        _(\"Importing data\"),\n        {\n            \"fields\": (\n                \"input_errors_file\",\n                \"_input_errors\",\n            ),\n            \"classes\": (\"collapse\",),\n        },\n    )\n\n    if obj.import_status == models.ImportJob.ImportStatus.CREATED:\n        return [status, import_params]\n\n    if obj.import_status in models.ImportJob.success_statuses:\n        return [status, result, data, import_params]\n\n    if obj.import_status in models.ImportJob.progress_statuses:\n        return [status, progress, import_params]\n\n    return [status, traceback_, import_params]\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin.get_queryset","title":"<code>get_queryset(request)</code>","text":"<p>Override <code>get_queryset</code>.</p> <p>Do not get <code>result</code> from db because it can be rather big and is not used in admin.</p> Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>def get_queryset(self, request: WSGIRequest) -&gt; QuerySet:\n    \"\"\"Override `get_queryset`.\n\n    Do not get `result` from db because it can be rather big and is not\n    used in admin.\n\n    \"\"\"\n    return super().get_queryset(request).defer(\"result\")\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin.get_urls","title":"<code>get_urls()</code>","text":"<p>Add url to get current import job progress in JSON representation.</p> <p>/admin/import_export_extensions/importjob//progress/ Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>def get_urls(self) -&gt; list[URLPattern]:\n    \"\"\"Add url to get current import job progress in JSON representation.\n\n    /admin/import_export_extensions/importjob/&lt;job_id&gt;/progress/\n\n    \"\"\"\n    urls = super().get_urls()\n    import_urls = [\n        re_path(\n            r\"^(?P&lt;job_id&gt;\\d+)/progress/$\",\n            self.admin_site.admin_view(self.import_job_progress_view),\n            name=\"import_job_progress\",\n        ),\n    ]\n    return import_urls + urls\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.import_job_admin.ImportJobAdmin.import_job_progress_view","title":"<code>import_job_progress_view(request, job_id, **kwargs)</code>","text":"<p>View to return <code>ImportJob</code> status as JSON.</p> <p>If current status is parsing/importing, view also returns job state and percent of completed work.</p> Return <p>Response: dictionary with status (optionally, state and percent).</p> Source code in <code>import_export_extensions/admin/model_admins/import_job_admin.py</code> <pre><code>def import_job_progress_view(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n    **kwargs,\n) -&gt; JsonResponse:\n    \"\"\"View to return ``ImportJob`` status as JSON.\n\n    If current status is parsing/importing, view also returns job state\n    and percent of completed work.\n\n    Return:\n        Response: dictionary with status (optionally, state and percent).\n\n    \"\"\"\n    try:\n        job: models.ImportJob = self.import_job_model.objects.get(\n            id=job_id,\n        )\n    except self.import_job_model.DoesNotExist as error:\n        return JsonResponse(\n            {\"validation_error\": error.args[0]},\n            status=http.HTTPStatus.NOT_FOUND,\n        )\n\n    response_data = {\"status\": job.import_status.title()}\n\n    if job.import_status not in models.ImportJob.progress_statuses:\n        return JsonResponse(response_data)\n\n    percent = 0\n    total = 0\n    current = 0\n    job_progress = job.progress\n    progress_info = job_progress[\"info\"]\n\n    if progress_info and progress_info[\"total\"]:\n        total = progress_info[\"total\"]\n        current = progress_info[\"current\"]\n        percent = int(100 / total * current)\n\n    response_data.update(\n        state=job_progress[\"state\"],\n        percent=percent,\n        total=total,\n        current=current,\n    )\n\n    return JsonResponse(response_data)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.mixins.BaseImportExportJobAdminMixin","title":"<code>BaseImportExportJobAdminMixin</code>","text":"<p>Mixin provides common methods for ImportJob and ExportJob admins.</p> Source code in <code>import_export_extensions/admin/model_admins/mixins.py</code> <pre><code>class BaseImportExportJobAdminMixin:\n    \"\"\"Mixin provides common methods for ImportJob and ExportJob admins.\"\"\"\n\n    def has_add_permission(\n        self,\n        request: WSGIRequest,\n        *args,\n        **kwargs,\n    ) -&gt; bool:\n        \"\"\"Import/Export Jobs should not be created using this interface.\"\"\"\n        return False\n\n    def has_delete_permission(\n        self,\n        request: WSGIRequest,\n        *args,\n        **kwargs,\n    ) -&gt; bool:\n        \"\"\"Import/Export Jobs should not be deleted using this interface.\n\n        Instead, admins must cancel jobs.\n\n        \"\"\"\n        return False\n\n    def _model(self, obj: BaseJob) -&gt; str:\n        \"\"\"Add `model` field of import/export job.\"\"\"\n        try:\n            resource_class = import_string(obj.resource_path)\n            model = resource_class.Meta.model._meta.verbose_name_plural\n        # In case resource has no Meta or model we need to catch AttributeError\n        except (ImportError, AttributeError):  # pragma: no cover\n            model = _(\"Unknown\")\n        return model\n\n    _model.short_description = _(\"Model\")\n\n    def get_from_content_type(\n        self,\n        obj: BaseJob,\n    ) -&gt; ContentType | None:  # pragma: no cover\n        \"\"\"Shortcut to get object from content_type.\"\"\"\n        content_type = obj.resource_kwargs.get(\"content_type\")\n        obj_id = obj.resource_kwargs.get(\"object_id\")\n\n        if content_type and obj_id:\n            content_type = ContentType.objects.get(id=content_type)\n            return content_type.model_class().objects.filter(id=obj_id).first()\n        return None\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.mixins.BaseImportExportJobAdminMixin.get_from_content_type","title":"<code>get_from_content_type(obj)</code>","text":"<p>Shortcut to get object from content_type.</p> Source code in <code>import_export_extensions/admin/model_admins/mixins.py</code> <pre><code>def get_from_content_type(\n    self,\n    obj: BaseJob,\n) -&gt; ContentType | None:  # pragma: no cover\n    \"\"\"Shortcut to get object from content_type.\"\"\"\n    content_type = obj.resource_kwargs.get(\"content_type\")\n    obj_id = obj.resource_kwargs.get(\"object_id\")\n\n    if content_type and obj_id:\n        content_type = ContentType.objects.get(id=content_type)\n        return content_type.model_class().objects.filter(id=obj_id).first()\n    return None\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.mixins.BaseImportExportJobAdminMixin.has_add_permission","title":"<code>has_add_permission(request, *args, **kwargs)</code>","text":"<p>Import/Export Jobs should not be created using this interface.</p> Source code in <code>import_export_extensions/admin/model_admins/mixins.py</code> <pre><code>def has_add_permission(\n    self,\n    request: WSGIRequest,\n    *args,\n    **kwargs,\n) -&gt; bool:\n    \"\"\"Import/Export Jobs should not be created using this interface.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.model_admins.mixins.BaseImportExportJobAdminMixin.has_delete_permission","title":"<code>has_delete_permission(request, *args, **kwargs)</code>","text":"<p>Import/Export Jobs should not be deleted using this interface.</p> <p>Instead, admins must cancel jobs.</p> Source code in <code>import_export_extensions/admin/model_admins/mixins.py</code> <pre><code>def has_delete_permission(\n    self,\n    request: WSGIRequest,\n    *args,\n    **kwargs,\n) -&gt; bool:\n    \"\"\"Import/Export Jobs should not be deleted using this interface.\n\n    Instead, admins must cancel jobs.\n\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.forms.export_job_admin_form.ExportJobAdminForm","title":"<code>ExportJobAdminForm</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Admin form for <code>ExportJob</code> model.</p> <p>Adds custom <code>export_progressbar</code> field that displays current export progress using AJAX requests to specified endpoint. Fields widget is defined in <code>__init__</code> method.</p> Source code in <code>import_export_extensions/admin/forms/export_job_admin_form.py</code> <pre><code>class ExportJobAdminForm(forms.ModelForm):\n    \"\"\"Admin form for `ExportJob` model.\n\n    Adds custom `export_progressbar` field that displays current export\n    progress using AJAX requests to specified endpoint. Fields widget is\n    defined in `__init__` method.\n\n    \"\"\"\n\n    export_progressbar = forms.Field(\n        label=\"Export progress\",\n        required=False,\n    )\n\n    def __init__(\n        self,\n        instance: models.ExportJob,\n        *args,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Provide `export_progressbar` widget the `ExportJob` instance.\"\"\"\n        super().__init__(*args, instance=instance, **kwargs)\n        url_name = \"admin:export_job_progress\"\n        self.fields[\"export_progressbar\"].widget = ProgressBarWidget(\n            job=instance,\n            url=reverse(url_name, args=(instance.id,)),\n        )\n\n    class Meta:\n        fields = (\n            \"export_status\",\n            \"resource_path\",\n            \"file_format_path\",\n            \"data_file\",\n            \"resource_kwargs\",\n            \"traceback\",\n            \"error_message\",\n            \"result\",\n            \"export_task_id\",\n            \"export_started\",\n            \"export_finished\",\n            \"created_by\",\n            \"created\",\n            \"modified\",\n        )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.forms.export_job_admin_form.ExportJobAdminForm.__init__","title":"<code>__init__(instance, *args, **kwargs)</code>","text":"<p>Provide <code>export_progressbar</code> widget the <code>ExportJob</code> instance.</p> Source code in <code>import_export_extensions/admin/forms/export_job_admin_form.py</code> <pre><code>def __init__(\n    self,\n    instance: models.ExportJob,\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Provide `export_progressbar` widget the `ExportJob` instance.\"\"\"\n    super().__init__(*args, instance=instance, **kwargs)\n    url_name = \"admin:export_job_progress\"\n    self.fields[\"export_progressbar\"].widget = ProgressBarWidget(\n        job=instance,\n        url=reverse(url_name, args=(instance.id,)),\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.forms.import_job_admin_form.ImportJobAdminForm","title":"<code>ImportJobAdminForm</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Admin form for <code>ImportJob</code> model.</p> <p>Adds custom <code>import_progressbar</code> field that displays current import progress using AJAX requests to specified endpoint. Fields widget is defined in <code>__init__</code> method.</p> Source code in <code>import_export_extensions/admin/forms/import_job_admin_form.py</code> <pre><code>class ImportJobAdminForm(forms.ModelForm):\n    \"\"\"Admin form for ``ImportJob`` model.\n\n    Adds custom `import_progressbar` field that displays current import\n    progress using AJAX requests to specified endpoint. Fields widget is\n    defined in `__init__` method.\n\n    \"\"\"\n\n    import_progressbar = forms.Field(\n        required=False,\n    )\n\n    def __init__(\n        self,\n        instance: models.ImportJob,\n        *args,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Provide `import_progressbar` widget the ``ImportJob`` instance.\"\"\"\n        super().__init__(*args, instance=instance, **kwargs)\n        url_name = \"admin:import_job_progress\"\n        self.fields[\"import_progressbar\"].label = (\n            \"Import progress\" if\n            instance.import_status == models.ImportJob.ImportStatus.IMPORTING\n            else \"Parsing progress\"\n        )\n        self.fields[\"import_progressbar\"].widget = ProgressBarWidget(\n            job=instance,\n            url=reverse(url_name, args=(instance.id,)),\n        )\n\n    class Meta:\n        fields = (\n            \"import_status\",\n            \"resource_path\",\n            \"data_file\",\n            \"resource_kwargs\",\n            \"traceback\",\n            \"error_message\",\n            \"result\",\n            \"parse_task_id\",\n            \"import_task_id\",\n            \"parse_finished\",\n            \"import_started\",\n            \"import_finished\",\n            \"created_by\",\n            \"created\",\n            \"modified\",\n        )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.forms.import_job_admin_form.ImportJobAdminForm.__init__","title":"<code>__init__(instance, *args, **kwargs)</code>","text":"<p>Provide <code>import_progressbar</code> widget the <code>ImportJob</code> instance.</p> Source code in <code>import_export_extensions/admin/forms/import_job_admin_form.py</code> <pre><code>def __init__(\n    self,\n    instance: models.ImportJob,\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Provide `import_progressbar` widget the ``ImportJob`` instance.\"\"\"\n    super().__init__(*args, instance=instance, **kwargs)\n    url_name = \"admin:import_job_progress\"\n    self.fields[\"import_progressbar\"].label = (\n        \"Import progress\" if\n        instance.import_status == models.ImportJob.ImportStatus.IMPORTING\n        else \"Parsing progress\"\n    )\n    self.fields[\"import_progressbar\"].widget = ProgressBarWidget(\n        job=instance,\n        url=reverse(url_name, args=(instance.id,)),\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.forms.import_admin_form.ForceImportForm","title":"<code>ForceImportForm</code>","text":"<p>               Bases: <code>ImportForm</code></p> <p>Import form with <code>force_import</code> option.</p> Source code in <code>import_export_extensions/admin/forms/import_admin_form.py</code> <pre><code>class ForceImportForm(base_forms.ImportForm):\n    \"\"\"Import form with `force_import` option.\"\"\"\n\n    force_import = forms.BooleanField(\n        required=False,\n        initial=False,\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.types.ModelInfo","title":"<code>ModelInfo</code>  <code>dataclass</code>","text":"<p>Contain base info about imported model.</p> Source code in <code>import_export_extensions/admin/mixins/types.py</code> <pre><code>@dataclasses.dataclass\nclass ModelInfo:\n    \"\"\"Contain base info about imported model.\"\"\"\n\n    meta: Options\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get name of model.\"\"\"\n        return self.meta.model_name\n\n    @property\n    def app_label(self) -&gt; str:\n        \"\"\"App label of model.\"\"\"\n        return self.meta.app_label\n\n    @property\n    def app_model_name(self) -&gt; str:\n        \"\"\"Return url name.\"\"\"\n        return f\"{self.app_label}_{self.name}\"\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.types.ModelInfo.app_label","title":"<code>app_label</code>  <code>property</code>","text":"<p>App label of model.</p>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.types.ModelInfo.app_model_name","title":"<code>app_model_name</code>  <code>property</code>","text":"<p>Return url name.</p>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.types.ModelInfo.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get name of model.</p>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin","title":"<code>CeleryExportAdminMixin</code>","text":"<p>               Bases: <code>BaseExportMixin</code>, <code>BaseCeleryImportExportAdminMixin</code></p> <p>Admin mixin for celery export.</p> Admin export work-flow is <p>GET <code>celery_export_action()</code> - display form with format type input</p> <p>POST <code>celery_export_action()</code> - create ExportJob and starts data export     This view redirects to next view:</p> <p>GET <code>celery_export_job_status_view()</code> - display ExportJob status (with     progress bar). When data exporting is done, redirect to next view:</p> <p>GET <code>celery_export_job_results_view()</code> - display export results. If no     errors - success message and link to the file with exported data.     If errors - traceback and error message.</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>class CeleryExportAdminMixin(\n    import_export_mixins.BaseExportMixin,\n    base_mixin.BaseCeleryImportExportAdminMixin,\n):\n    \"\"\"Admin mixin for celery export.\n\n    Admin export work-flow is:\n        GET `celery_export_action()` - display form with format type input\n\n        POST `celery_export_action()` - create ExportJob and starts data export\n            This view redirects to next view:\n\n        GET `celery_export_job_status_view()` - display ExportJob status (with\n            progress bar). When data exporting is done, redirect to next view:\n\n        GET `celery_export_job_results_view()` - display export results. If no\n            errors - success message and link to the file with exported data.\n            If errors - traceback and error message.\n\n    \"\"\"\n\n    # export data encoding\n    to_encoding = \"utf-8\"\n\n    export_form_class: type[import_export_forms.ExportForm] = (\n        import_export_forms.SelectableFieldsExportForm\n    )\n\n    # template used to display ExportForm\n    celery_export_template_name = \"admin/import_export/export.html\"\n\n    export_status_template_name = (\n        \"admin/import_export_extensions/celery_export_status.html\"\n    )\n\n    export_results_template_name = (\n        \"admin/import_export_extensions/celery_export_results.html\"\n    )\n\n    import_export_change_list_template = (\n        \"admin/import_export/change_list_export.html\"\n    )\n\n    # Statuses that should be displayed on 'results' page\n    export_results_statuses = models.ExportJob.export_finished_statuses\n\n    # Copy methods of mixin from original package to reuse it here\n    has_export_permission = (\n        import_export_admin.ExportMixin.has_export_permission\n    )\n    get_export_form_class = import_export_admin.ExportMixin.get_export_form_class  # noqa\n    get_export_resource_fields_from_form = import_export_admin.ExportMixin.get_export_resource_fields_from_form  # noqa\n    is_skip_export_form_enabled = import_export_admin.ExportMixin.is_skip_export_form_enabled  # noqa\n\n    def get_export_context_data(self, **kwargs) -&gt; dict[str, typing.Any]:\n        \"\"\"Get context data for export.\"\"\"\n        return self.get_context_data(**kwargs)\n\n    def get_urls(self) -&gt; list[URLPattern]:\n        \"\"\"Return list of urls.\n\n        /&lt;model/celery-export/:\n            ExportForm ('export_action' method)\n        /&lt;model&gt;/celery-export/&lt;ID&gt;/:\n            status of ExportJob and progress bar ('export_job_status_view')\n        /&lt;model&gt;/celery-export/&lt;ID&gt;/results/:\n            table with export results (errors)\n\n        \"\"\"\n        urls = super().get_urls()\n        export_urls = [\n            re_path(\n                r\"^celery-export/$\",\n                self.admin_site.admin_view(self.celery_export_action),\n                name=f\"{self.model_info.app_model_name}_export\",\n            ),\n            re_path(\n                r\"^celery-export/(?P&lt;job_id&gt;\\d+)/$\",\n                self.admin_site.admin_view(self.export_job_status_view),\n                name=(\n                    f\"{self.model_info.app_model_name}\"\n                    f\"_export_job_status\"\n                ),\n            ),\n            re_path(\n                r\"^celery-export/(?P&lt;job_id&gt;\\d+)/results/$\",\n                self.admin_site.admin_view(\n                    self.export_job_results_view,\n                ),\n                name=(\n                    f\"{self.model_info.app_model_name}\"\n                    f\"_export_job_results\"\n                ),\n            ),\n        ]\n        return export_urls + urls\n\n    def celery_export_action(\n        self,\n        request: WSGIRequest,\n        *args,\n        **kwargs,\n    ) -&gt; HttpResponse | TemplateResponse:\n        \"\"\"Show and handle export.\n\n        GET: show export form with format_type input\n        POST: create ExportJob instance and redirect to it's status\n\n        \"\"\"\n        if not self.has_export_permission(request):\n            raise PermissionDenied\n\n        formats = self.get_export_formats()\n        resource_kwargs = self.get_export_resource_kwargs(\n            *args,\n            **kwargs,\n            request=request,\n        )\n        if self.is_skip_export_form_enabled():\n            job = self.create_export_job(\n                request=request,\n                resource_class=self.get_export_resource_classes(request)[0],\n                resource_kwargs=resource_kwargs,\n                file_format=formats[0],\n            )\n            return self._redirect_to_export_status_page(\n                request=request,\n                job=job,\n            )\n\n        form_type = self.get_export_form_class()\n        form = form_type(\n            formats=formats,\n            resources=self.get_export_resource_classes(request),\n            data=request.POST or None,\n        )\n\n        if request.method == \"POST\" and form.is_valid():\n            file_format = formats[int(form.cleaned_data[\"format\"])]\n            # Get the selected export fields from the form\n            resource_kwargs[\"export_fields\"] = (\n                self.get_export_resource_fields_from_form(form)\n            )\n            # create ExportJob and redirect to page with it's status\n            job = self.create_export_job(\n                request=request,\n                resource_class=self.choose_export_resource_class(\n                    form,\n                    request,\n                ),\n                resource_kwargs=resource_kwargs,\n                file_format=file_format,\n            )\n            return self._redirect_to_export_status_page(\n                request=request,\n                job=job,\n            )\n\n        # GET: display Export Form\n        context = self.get_export_context_data()\n        context.update(self.admin_site.each_context(request))\n\n        context[\"title\"] = _(\"Export\")\n        context[\"form\"] = form\n        context[\"opts\"] = self.model_info.meta\n        request.current_app = self.admin_site.name\n\n        return TemplateResponse(\n            request=request,\n            template=[self.celery_export_template_name],\n            context=context,\n        )\n\n    def export_job_status_view(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n        **kwargs,\n    ) -&gt; HttpResponse:\n        \"\"\"View to track export job status.\n\n        Displays current export job status and progress (using JS + another\n        view).\n\n        If job result is ready - redirects to another page to see results.\n\n        \"\"\"\n        if not self.has_export_permission(request):\n            raise PermissionDenied\n\n        job = self.get_export_job(request=request, job_id=job_id)\n        if job.export_status in self.export_results_statuses:\n            return self._redirect_to_export_results_page(\n                request=request,\n                job=job,\n            )\n\n        context = self.get_export_context_data()\n        job_url = reverse(\"admin:export_job_progress\", args=(job.id,))\n\n        context[\"title\"] = _(\"Export status\")\n        context[\"opts\"] = self.model_info.meta\n        context[\"export_job\"] = job\n        context[\"export_job_url\"] = job_url\n        request.current_app = self.admin_site.name\n        return TemplateResponse(\n            request=request,\n            template=[self.export_status_template_name],\n            context=context,\n        )\n\n    def export_job_results_view(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n        *args,\n        **kwargs,\n    ) -&gt; HttpResponse:\n        \"\"\"Display export results.\n\n        GET-request:\n            * show message\n            * if no errors - show file link\n            * if errors - show traceback and error\n\n        \"\"\"\n        if not self.has_export_permission(request):\n            raise PermissionDenied\n\n        job = self.get_export_job(request=request, job_id=job_id)\n        if job.export_status not in self.export_results_statuses:\n            return self._redirect_to_export_status_page(\n                request=request,\n                job=job,\n            )\n\n        context = self.get_export_context_data()\n\n        # GET request, show export results\n        context[\"title\"] = _(\"Export results\")\n        context[\"opts\"] = self.model._meta\n        context[\"export_job\"] = job\n        context[\"result\"] = job.export_status\n\n        return TemplateResponse(\n            request=request,\n            template=[self.export_results_template_name],\n            context=context,\n        )\n\n    def create_export_job(\n        self,\n        request: WSGIRequest,\n        resource_class: types.ResourceType,\n        resource_kwargs: dict[str, typing.Any],\n        file_format: types.FormatType,\n    ) -&gt; models.ExportJob:\n        \"\"\"Create and return instance of export job with chosen format.\"\"\"\n        job = models.ExportJob.objects.create(\n            resource_path=resource_class.class_path,\n            resource_kwargs=resource_kwargs,\n            created_by=request.user,\n            file_format_path=(\n                f\"{file_format.__module__}.{file_format.__name__}\"\n            ),\n        )\n        return job\n\n    def get_export_job(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n    ) -&gt; models.ExportJob:\n        \"\"\"Get ExportJob instance.\n\n        Raises\n            Http404\n\n        \"\"\"\n        return get_object_or_404(models.ExportJob, id=job_id)\n\n    def get_resource_kwargs(\n        self,\n        request: WSGIRequest,\n        *args,\n        **kwargs,\n    ) -&gt; dict[str, typing.Any]:\n        \"\"\"Return filter kwargs for resource queryset.\"\"\"\n        resource_kwargs = super().get_resource_kwargs(request, *args, **kwargs)\n        resource_kwargs[\"admin_filters\"] = {\n            \"pk__in\": list(\n                self.get_changelist_instance(request)\n                .get_queryset(request)\n                .values_list(\"pk\", flat=True),\n            ),\n        }\n        return resource_kwargs\n\n    def _redirect_to_export_status_page(\n        self,\n        request: WSGIRequest,\n        job: models.ExportJob,\n    ) -&gt; HttpResponse:\n        \"\"\"Shortcut for redirecting to job's status page.\"\"\"\n        url_name = (\n            f\"admin:{self.model_info.app_model_name}_export_job_status\"\n        )\n        url = reverse(url_name, kwargs={\"job_id\": job.id})\n        query = request.GET.urlencode()\n        url = f\"{url}?{query}\" if query else url\n        return HttpResponseRedirect(redirect_to=url)\n\n    def _redirect_to_export_results_page(\n        self,\n        request: WSGIRequest,\n        job: models.ExportJob,\n    ) -&gt; HttpResponse:\n        \"\"\"Shortcut for redirecting to job's results page.\"\"\"\n        url_name = (\n            f\"admin:{self.model_info.app_model_name}_export_job_results\"\n        )\n        url = reverse(url_name, kwargs={\"job_id\": job.id})\n        query = request.GET.urlencode()\n        url = f\"{url}?{query}\" if query else url\n        return HttpResponseRedirect(redirect_to=url)\n\n    def changelist_view(\n        self,\n        request: WSGIRequest,\n        context: dict[str, typing.Any] | None = None,\n    ) -&gt; HttpResponse:\n        \"\"\"Add the check for permission to changelist template context.\"\"\"\n        context = context or {}\n        context[\"has_export_permission\"] = self.has_export_permission(request)\n        return super().changelist_view(request, context)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.celery_export_action","title":"<code>celery_export_action(request, *args, **kwargs)</code>","text":"<p>Show and handle export.</p> <p>GET: show export form with format_type input POST: create ExportJob instance and redirect to it's status</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def celery_export_action(\n    self,\n    request: WSGIRequest,\n    *args,\n    **kwargs,\n) -&gt; HttpResponse | TemplateResponse:\n    \"\"\"Show and handle export.\n\n    GET: show export form with format_type input\n    POST: create ExportJob instance and redirect to it's status\n\n    \"\"\"\n    if not self.has_export_permission(request):\n        raise PermissionDenied\n\n    formats = self.get_export_formats()\n    resource_kwargs = self.get_export_resource_kwargs(\n        *args,\n        **kwargs,\n        request=request,\n    )\n    if self.is_skip_export_form_enabled():\n        job = self.create_export_job(\n            request=request,\n            resource_class=self.get_export_resource_classes(request)[0],\n            resource_kwargs=resource_kwargs,\n            file_format=formats[0],\n        )\n        return self._redirect_to_export_status_page(\n            request=request,\n            job=job,\n        )\n\n    form_type = self.get_export_form_class()\n    form = form_type(\n        formats=formats,\n        resources=self.get_export_resource_classes(request),\n        data=request.POST or None,\n    )\n\n    if request.method == \"POST\" and form.is_valid():\n        file_format = formats[int(form.cleaned_data[\"format\"])]\n        # Get the selected export fields from the form\n        resource_kwargs[\"export_fields\"] = (\n            self.get_export_resource_fields_from_form(form)\n        )\n        # create ExportJob and redirect to page with it's status\n        job = self.create_export_job(\n            request=request,\n            resource_class=self.choose_export_resource_class(\n                form,\n                request,\n            ),\n            resource_kwargs=resource_kwargs,\n            file_format=file_format,\n        )\n        return self._redirect_to_export_status_page(\n            request=request,\n            job=job,\n        )\n\n    # GET: display Export Form\n    context = self.get_export_context_data()\n    context.update(self.admin_site.each_context(request))\n\n    context[\"title\"] = _(\"Export\")\n    context[\"form\"] = form\n    context[\"opts\"] = self.model_info.meta\n    request.current_app = self.admin_site.name\n\n    return TemplateResponse(\n        request=request,\n        template=[self.celery_export_template_name],\n        context=context,\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.changelist_view","title":"<code>changelist_view(request, context=None)</code>","text":"<p>Add the check for permission to changelist template context.</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def changelist_view(\n    self,\n    request: WSGIRequest,\n    context: dict[str, typing.Any] | None = None,\n) -&gt; HttpResponse:\n    \"\"\"Add the check for permission to changelist template context.\"\"\"\n    context = context or {}\n    context[\"has_export_permission\"] = self.has_export_permission(request)\n    return super().changelist_view(request, context)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.create_export_job","title":"<code>create_export_job(request, resource_class, resource_kwargs, file_format)</code>","text":"<p>Create and return instance of export job with chosen format.</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def create_export_job(\n    self,\n    request: WSGIRequest,\n    resource_class: types.ResourceType,\n    resource_kwargs: dict[str, typing.Any],\n    file_format: types.FormatType,\n) -&gt; models.ExportJob:\n    \"\"\"Create and return instance of export job with chosen format.\"\"\"\n    job = models.ExportJob.objects.create(\n        resource_path=resource_class.class_path,\n        resource_kwargs=resource_kwargs,\n        created_by=request.user,\n        file_format_path=(\n            f\"{file_format.__module__}.{file_format.__name__}\"\n        ),\n    )\n    return job\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.export_job_results_view","title":"<code>export_job_results_view(request, job_id, *args, **kwargs)</code>","text":"<p>Display export results.</p> GET-request <ul> <li>show message</li> <li>if no errors - show file link</li> <li>if errors - show traceback and error</li> </ul> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def export_job_results_view(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n    *args,\n    **kwargs,\n) -&gt; HttpResponse:\n    \"\"\"Display export results.\n\n    GET-request:\n        * show message\n        * if no errors - show file link\n        * if errors - show traceback and error\n\n    \"\"\"\n    if not self.has_export_permission(request):\n        raise PermissionDenied\n\n    job = self.get_export_job(request=request, job_id=job_id)\n    if job.export_status not in self.export_results_statuses:\n        return self._redirect_to_export_status_page(\n            request=request,\n            job=job,\n        )\n\n    context = self.get_export_context_data()\n\n    # GET request, show export results\n    context[\"title\"] = _(\"Export results\")\n    context[\"opts\"] = self.model._meta\n    context[\"export_job\"] = job\n    context[\"result\"] = job.export_status\n\n    return TemplateResponse(\n        request=request,\n        template=[self.export_results_template_name],\n        context=context,\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.export_job_status_view","title":"<code>export_job_status_view(request, job_id, **kwargs)</code>","text":"<p>View to track export job status.</p> <p>Displays current export job status and progress (using JS + another view).</p> <p>If job result is ready - redirects to another page to see results.</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def export_job_status_view(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n    **kwargs,\n) -&gt; HttpResponse:\n    \"\"\"View to track export job status.\n\n    Displays current export job status and progress (using JS + another\n    view).\n\n    If job result is ready - redirects to another page to see results.\n\n    \"\"\"\n    if not self.has_export_permission(request):\n        raise PermissionDenied\n\n    job = self.get_export_job(request=request, job_id=job_id)\n    if job.export_status in self.export_results_statuses:\n        return self._redirect_to_export_results_page(\n            request=request,\n            job=job,\n        )\n\n    context = self.get_export_context_data()\n    job_url = reverse(\"admin:export_job_progress\", args=(job.id,))\n\n    context[\"title\"] = _(\"Export status\")\n    context[\"opts\"] = self.model_info.meta\n    context[\"export_job\"] = job\n    context[\"export_job_url\"] = job_url\n    request.current_app = self.admin_site.name\n    return TemplateResponse(\n        request=request,\n        template=[self.export_status_template_name],\n        context=context,\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.get_export_context_data","title":"<code>get_export_context_data(**kwargs)</code>","text":"<p>Get context data for export.</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def get_export_context_data(self, **kwargs) -&gt; dict[str, typing.Any]:\n    \"\"\"Get context data for export.\"\"\"\n    return self.get_context_data(**kwargs)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.get_export_job","title":"<code>get_export_job(request, job_id)</code>","text":"<p>Get ExportJob instance.</p> <p>Raises     Http404</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def get_export_job(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n) -&gt; models.ExportJob:\n    \"\"\"Get ExportJob instance.\n\n    Raises\n        Http404\n\n    \"\"\"\n    return get_object_or_404(models.ExportJob, id=job_id)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.get_resource_kwargs","title":"<code>get_resource_kwargs(request, *args, **kwargs)</code>","text":"<p>Return filter kwargs for resource queryset.</p> Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def get_resource_kwargs(\n    self,\n    request: WSGIRequest,\n    *args,\n    **kwargs,\n) -&gt; dict[str, typing.Any]:\n    \"\"\"Return filter kwargs for resource queryset.\"\"\"\n    resource_kwargs = super().get_resource_kwargs(request, *args, **kwargs)\n    resource_kwargs[\"admin_filters\"] = {\n        \"pk__in\": list(\n            self.get_changelist_instance(request)\n            .get_queryset(request)\n            .values_list(\"pk\", flat=True),\n        ),\n    }\n    return resource_kwargs\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.export_mixin.CeleryExportAdminMixin.get_urls","title":"<code>get_urls()</code>","text":"<p>Return list of urls.</p> <p>/&lt;model/celery-export/:     ExportForm ('export_action' method) //celery-export//:     status of ExportJob and progress bar ('export_job_status_view') //celery-export//results/:     table with export results (errors) Source code in <code>import_export_extensions/admin/mixins/export_mixin.py</code> <pre><code>def get_urls(self) -&gt; list[URLPattern]:\n    \"\"\"Return list of urls.\n\n    /&lt;model/celery-export/:\n        ExportForm ('export_action' method)\n    /&lt;model&gt;/celery-export/&lt;ID&gt;/:\n        status of ExportJob and progress bar ('export_job_status_view')\n    /&lt;model&gt;/celery-export/&lt;ID&gt;/results/:\n        table with export results (errors)\n\n    \"\"\"\n    urls = super().get_urls()\n    export_urls = [\n        re_path(\n            r\"^celery-export/$\",\n            self.admin_site.admin_view(self.celery_export_action),\n            name=f\"{self.model_info.app_model_name}_export\",\n        ),\n        re_path(\n            r\"^celery-export/(?P&lt;job_id&gt;\\d+)/$\",\n            self.admin_site.admin_view(self.export_job_status_view),\n            name=(\n                f\"{self.model_info.app_model_name}\"\n                f\"_export_job_status\"\n            ),\n        ),\n        re_path(\n            r\"^celery-export/(?P&lt;job_id&gt;\\d+)/results/$\",\n            self.admin_site.admin_view(\n                self.export_job_results_view,\n            ),\n            name=(\n                f\"{self.model_info.app_model_name}\"\n                f\"_export_job_results\"\n            ),\n        ),\n    ]\n    return export_urls + urls\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_export_mixin.CeleryImportExportMixin","title":"<code>CeleryImportExportMixin</code>","text":"<p>               Bases: <code>CeleryImportAdminMixin</code>, <code>CeleryExportAdminMixin</code></p> <p>Import and export mixin.</p> Source code in <code>import_export_extensions/admin/mixins/import_export_mixin.py</code> <pre><code>class CeleryImportExportMixin(\n    CeleryImportAdminMixin,\n    CeleryExportAdminMixin,\n):\n    \"\"\"Import and export mixin.\"\"\"\n\n    # template for change_list view\n    import_export_change_list_template = (\n        \"admin/import_export/change_list_import_export.html\"\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin","title":"<code>CeleryImportAdminMixin</code>","text":"<p>               Bases: <code>BaseImportMixin</code>, <code>BaseCeleryImportExportAdminMixin</code></p> <p>Admin mixin for celery import.</p> <p>Admin import work-flow is:</p> <p>GET <code>celery_import_action()</code> - display form with import file input</p> <p>POST <code>celery_import_action()</code> - save file and create ImportJob.     This view redirects to next view:</p> <p>GET <code>celery_import_job_status_view()</code> - display ImportJob status (with     progress bar and critical errors occurred). When data parsing is     done, redirect to next view:</p> <p>GET <code>celery_import_job_results_view()</code> - display rows that will be     imported and data parse errors. If no errors - next step.     If errors - display same form as in <code>import_action()</code></p> <p>POST <code>celery_import_job_results_view()</code> - start data importing and     redirect back to GET <code>celery_import_job_status_view()</code>     with progress bar and import totals.</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>class CeleryImportAdminMixin(\n    import_export_mixins.BaseImportMixin,\n    base_mixin.BaseCeleryImportExportAdminMixin,\n):\n    \"\"\"Admin mixin for celery import.\n\n    Admin import work-flow is:\n\n    GET ``celery_import_action()`` - display form with import file input\n\n    POST ``celery_import_action()`` - save file and create ImportJob.\n        This view redirects to next view:\n\n    GET ``celery_import_job_status_view()`` - display ImportJob status (with\n        progress bar and critical errors occurred). When data parsing is\n        done, redirect to next view:\n\n    GET ``celery_import_job_results_view()`` - display rows that will be\n        imported and data parse errors. If no errors - next step.\n        If errors - display same form as in ``import_action()``\n\n    POST ``celery_import_job_results_view()`` - start data importing and\n        redirect back to GET ``celery_import_job_status_view()``\n        with progress bar and import totals.\n\n    \"\"\"\n\n    # Import data encoding\n    from_encoding = \"utf-8\"\n\n    import_form_class: type[ImportForm] = ForceImportForm\n    confirm_form_class: type[ConfirmImportForm] = ConfirmImportForm\n\n    # Statuses that should be displayed on 'results' page\n    results_statuses = models.ImportJob.results_statuses\n\n    # Template used to display ImportForm\n    celery_import_template = \"admin/import_export/import.html\"\n\n    # Template used to display status of import jobs\n    import_status_template = (\n        \"admin/import_export_extensions/celery_import_status.html\"\n    )\n\n    # template used to display results of import jobs\n    import_result_template_name = (\n        \"admin/import_export_extensions/celery_import_results.html\"\n    )\n\n    import_export_change_list_template = (\n        \"admin/import_export/change_list_import.html\"\n    )\n\n    skip_admin_log = None\n    # Copy methods of mixin from original package to reuse it here\n    generate_log_entries = import_export_admin.ImportMixin.generate_log_entries\n    get_skip_admin_log = import_export_admin.ImportMixin.get_skip_admin_log\n    has_import_permission = (\n        import_export_admin.ImportMixin.has_import_permission\n    )\n    _log_actions = import_export_admin.ImportMixin._log_actions\n    _create_log_entries = import_export_admin.ImportMixin._create_log_entries\n    _create_log_entry = import_export_admin.ImportMixin._create_log_entry\n\n    # Copied form related methods\n    create_import_form = import_export_admin.ImportMixin.create_import_form\n    get_import_form_class = import_export_admin.ImportMixin.get_import_form_class  # noqa\n    get_import_form_kwargs = import_export_admin.ImportMixin.get_import_form_kwargs  # noqa\n    get_import_form_initial = import_export_admin.ImportMixin.get_import_form_initial  # noqa\n    create_confirm_form = import_export_admin.ImportMixin.create_confirm_form\n    get_confirm_form_class = import_export_admin.ImportMixin.get_confirm_form_class  # noqa\n    get_confirm_form_kwargs = import_export_admin.ImportMixin.get_confirm_form_kwargs  # noqa\n    get_confirm_form_initial = import_export_admin.ImportMixin.get_confirm_form_initial  # noqa\n\n    def get_import_context_data(self, **kwargs) -&gt; dict[str, typing.Any]:\n        \"\"\"Get context data for import.\"\"\"\n        return self.get_context_data(**kwargs)\n\n    def get_urls(self) -&gt; list[URLPattern]:\n        \"\"\"Return list of urls.\n\n        * /&lt;model&gt;/&lt;celery-import&gt;/:\n            ImportForm ('celery_import_action' method)\n        * /&lt;model&gt;/&lt;celery-import&gt;/&lt;ID&gt;/:\n            status of ImportJob and progress bar\n            ('celery_import_job_status_view')\n        * /&lt;model&gt;/&lt;celery-import&gt;/&lt;ID&gt;/results/:\n            table with import results (errors) and import confirmation\n            ('celery_import_job_results_view')\n\n        \"\"\"\n        urls = super().get_urls()\n        import_urls = [\n            re_path(\n                r\"^celery-import/$\",\n                self.admin_site.admin_view(self.celery_import_action),\n                name=f\"{self.model_info.app_model_name}_import\",\n            ),\n            re_path(\n                r\"^celery-import/(?P&lt;job_id&gt;\\d+)/$\",\n                self.admin_site.admin_view(self.celery_import_job_status_view),\n                name=(\n                    f\"{self.model_info.app_model_name}\"\n                    f\"_import_job_status\"\n                ),\n            ),\n            re_path(\n                r\"^celery-import/(?P&lt;job_id&gt;\\d+)/results/$\",\n                self.admin_site.admin_view(\n                    self.celery_import_job_results_view,\n                ),\n                name=(\n                    f\"{self.model_info.app_model_name}\"\n                    f\"_import_job_results\"\n                ),\n            ),\n        ]\n        return import_urls + urls\n\n    def celery_import_action(\n        self,\n        request: WSGIRequest,\n        *args,\n        **kwargs,\n    ) -&gt; HttpResponseRedirect | TemplateResponse:\n        \"\"\"Show and handle ImportForm.\n\n        GET:\n            show import form with data_file input form\n        POST:\n            create ImportJob instance and redirect to it's status\n\n        \"\"\"\n        if not self.has_import_permission(request):\n            raise PermissionDenied\n\n        context = self.get_import_context_data()\n        resource_classes = self.get_import_resource_classes(request)\n\n        form = self.create_import_form(request)\n        resource_kwargs = self.get_import_resource_kwargs(request)\n\n        if request.method == \"POST\" and form.is_valid():\n            # create ImportJob and redirect to page with it's status\n            resource_class = self.choose_import_resource_class(form, request)\n            job = self.create_import_job(\n                request=request,\n                resource=resource_class(**resource_kwargs),\n                form=form,\n            )\n            return self._redirect_to_import_status_page(\n                request=request,\n                job=job,\n            )\n\n        # GET: display Import Form\n        context.update(self.admin_site.each_context(request))\n\n        context[\"title\"] = _(\"Import\")\n        context[\"form\"] = form\n        context[\"opts\"] = self.model_info.meta\n        context[\"media\"] = self.media + form.media\n        context[\"fields_list\"] = self._get_fields_list_for_resources(\n            resource_classes=resource_classes,\n            resource_kwargs=resource_kwargs,\n        )\n\n        request.current_app = self.admin_site.name\n        return TemplateResponse(\n            request,\n            [self.celery_import_template],\n            context,\n        )\n\n    def celery_import_job_status_view(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n        **kwargs,\n    ) -&gt; HttpResponse:\n        \"\"\"View to track import job status.\n\n        Displays current import job status and progress (using JS + another\n        view).\n\n        If job result is ready - redirects to another page to see results.\n\n        Also generates admin log entries if the job has `IMPORTED` status.\n\n        \"\"\"\n        if not self.has_import_permission(request):\n            raise PermissionDenied\n\n        job = self.get_import_job(request, job_id)\n        if job.import_status in self.results_statuses:\n            if job.import_status == models.ImportJob.ImportStatus.IMPORTED:\n                self.generate_log_entries(job.result, request)\n            return self._redirect_to_results_page(\n                request=request,\n                job=job,\n            )\n\n        context = self.get_import_context_data()\n        job_url = reverse(\"admin:import_job_progress\", args=(job.id,))\n        context.update(\n            {\n                \"title\": _(\"Import status\"),\n                \"opts\": self.model_info.meta,\n                \"import_job\": job,\n                \"import_job_url\": job_url,\n            },\n        )\n        request.current_app = self.admin_site.name\n        return TemplateResponse(\n            request=request,\n            template=[self.import_status_template],\n            context=context,\n        )\n\n    def celery_import_job_results_view(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n        *args,\n        **kwargs,\n    ) -&gt; HttpResponse:\n        \"\"\"Display table with import results and import confirm form.\n\n        GET-request:\n            * show row results\n            * if data valid - show import confirmation form\n            * if data invalid - show ImportForm for uploading other file\n\n        POST-request:\n            * start data importing if data is correct\n\n        \"\"\"\n        if not self.has_import_permission(request):\n            raise PermissionDenied\n\n        job = self.get_import_job(request=request, job_id=job_id)\n        if job.import_status not in self.results_statuses:\n            return self._redirect_to_import_status_page(\n                request=request,\n                job=job,\n            )\n\n        context = self.get_import_context_data()\n\n        if request.method == \"GET\":\n            # GET request, show parse results\n            result = job.result\n            context[\"import_job\"] = job\n            context[\"result\"] = result\n            context[\"title\"] = _(\"Import results\")\n\n            if job.import_status == models.ImportJob.ImportStatus.PARSED:\n                context[\"confirm_form\"] = self.create_confirm_form(request)\n            else:\n                # display import form\n                resource_classes = self.get_import_resource_classes(request)\n                resource_kwargs = self.get_import_resource_kwargs(request)\n\n                context[\"import_form\"] = self.create_import_form(request)\n                context[\"fields_list\"] = self._get_fields_list_for_resources(\n                    resource_classes=resource_classes,\n                    resource_kwargs=resource_kwargs,\n                )\n\n            context.update(self.admin_site.each_context(request))\n            context[\"opts\"] = self.model_info.meta\n            request.current_app = self.admin_site.name\n            return TemplateResponse(\n                request,\n                [self.import_result_template_name],\n                context,\n            )\n\n        # POST request\n        if job.import_status == models.ImportJob.ImportStatus.PARSED:\n            # start celery task for data importing\n            job.confirm_import()\n            return self._redirect_to_import_status_page(\n                request=request,\n                job=job,\n            )\n\n        return HttpResponseForbidden(\n            \"Data invalid, before importing data \"\n            \"needs to be successfully parsed. \"\n            f\"Current status: {job.import_status}\",\n        )\n\n    def create_import_job(\n        self,\n        request: WSGIRequest,\n        form: Form,\n        resource: types.ResourceObj,\n    ) -&gt; models.ImportJob:\n        \"\"\"Create and return instance of import job.\"\"\"\n        return models.ImportJob.objects.create(\n            resource_path=resource.class_path,\n            data_file=form.cleaned_data[\"import_file\"],\n            resource_kwargs=resource.resource_init_kwargs,\n            created_by=request.user,\n            skip_parse_step=getattr(\n                settings,\n                \"IMPORT_EXPORT_SKIP_ADMIN_CONFIRM\",\n                False,\n            ),\n            force_import=form.cleaned_data.get(\"force_import\", False),\n        )\n\n    def get_import_job(\n        self,\n        request: WSGIRequest,\n        job_id: int,\n    ) -&gt; models.ImportJob:\n        \"\"\"Get ImportJob instance.\n\n        Raises\n            Http404\n\n        \"\"\"\n        return get_object_or_404(klass=models.ImportJob, id=job_id)\n\n    def _redirect_to_import_status_page(\n        self,\n        request: WSGIRequest,\n        job: models.ImportJob,\n    ) -&gt; HttpResponseRedirect:\n        \"\"\"Shortcut for redirecting to job's status page.\"\"\"\n        url_name = (\n            f\"admin:{self.model_info.app_model_name}_import_job_status\"\n        )\n        url = reverse(url_name, kwargs={\"job_id\": job.id})\n        query = request.GET.urlencode()\n        url = f\"{url}?{query}\" if query else url\n        return HttpResponseRedirect(redirect_to=url)\n\n    def _redirect_to_results_page(\n        self,\n        request: WSGIRequest,\n        job: models.ImportJob,\n    ) -&gt; HttpResponseRedirect:\n        \"\"\"Shortcut for redirecting to job's results page.\"\"\"\n        url_name = (\n            f\"admin:{self.model_info.app_model_name}_import_job_results\"\n        )\n        url = reverse(url_name, kwargs={\"job_id\": job.id})\n        query = request.GET.urlencode()\n        url = f\"{url}?{query}\" if query else url\n        if job.import_status != models.ImportJob.ImportStatus.PARSED:\n            return HttpResponseRedirect(redirect_to=url)\n\n        return HttpResponseRedirect(redirect_to=url)\n\n    def _get_fields_list_for_resources(\n        self,\n        resource_classes: list[type[import_export_resources.ModelResource]],\n        resource_kwargs,\n    ) -&gt; list[tuple[str, list[str]]]:\n        \"\"\"Get fields list for resource classes.\"\"\"\n        resources = [\n            resource_class(**resource_kwargs)\n            for resource_class in resource_classes\n        ]\n        return [\n            (\n                resource.get_display_name(),\n                [\n                    field.column_name\n                    for field in resource.get_user_visible_fields()\n                ],\n            )\n            for resource in resources\n        ]\n\n    def changelist_view(\n        self,\n        request: WSGIRequest,\n        context: dict[str, typing.Any] | None = None,\n    ) -&gt; HttpResponse:\n        \"\"\"Add the check for permission to changelist template context.\"\"\"\n        context = context or {}\n        context[\"has_import_permission\"] = self.has_import_permission(request)\n        return super().changelist_view(request, context)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.celery_import_action","title":"<code>celery_import_action(request, *args, **kwargs)</code>","text":"<p>Show and handle ImportForm.</p> GET <p>show import form with data_file input form</p> <p>POST:     create ImportJob instance and redirect to it's status</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def celery_import_action(\n    self,\n    request: WSGIRequest,\n    *args,\n    **kwargs,\n) -&gt; HttpResponseRedirect | TemplateResponse:\n    \"\"\"Show and handle ImportForm.\n\n    GET:\n        show import form with data_file input form\n    POST:\n        create ImportJob instance and redirect to it's status\n\n    \"\"\"\n    if not self.has_import_permission(request):\n        raise PermissionDenied\n\n    context = self.get_import_context_data()\n    resource_classes = self.get_import_resource_classes(request)\n\n    form = self.create_import_form(request)\n    resource_kwargs = self.get_import_resource_kwargs(request)\n\n    if request.method == \"POST\" and form.is_valid():\n        # create ImportJob and redirect to page with it's status\n        resource_class = self.choose_import_resource_class(form, request)\n        job = self.create_import_job(\n            request=request,\n            resource=resource_class(**resource_kwargs),\n            form=form,\n        )\n        return self._redirect_to_import_status_page(\n            request=request,\n            job=job,\n        )\n\n    # GET: display Import Form\n    context.update(self.admin_site.each_context(request))\n\n    context[\"title\"] = _(\"Import\")\n    context[\"form\"] = form\n    context[\"opts\"] = self.model_info.meta\n    context[\"media\"] = self.media + form.media\n    context[\"fields_list\"] = self._get_fields_list_for_resources(\n        resource_classes=resource_classes,\n        resource_kwargs=resource_kwargs,\n    )\n\n    request.current_app = self.admin_site.name\n    return TemplateResponse(\n        request,\n        [self.celery_import_template],\n        context,\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.celery_import_job_results_view","title":"<code>celery_import_job_results_view(request, job_id, *args, **kwargs)</code>","text":"<p>Display table with import results and import confirm form.</p> GET-request <ul> <li>show row results</li> <li>if data valid - show import confirmation form</li> <li>if data invalid - show ImportForm for uploading other file</li> </ul> POST-request <ul> <li>start data importing if data is correct</li> </ul> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def celery_import_job_results_view(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n    *args,\n    **kwargs,\n) -&gt; HttpResponse:\n    \"\"\"Display table with import results and import confirm form.\n\n    GET-request:\n        * show row results\n        * if data valid - show import confirmation form\n        * if data invalid - show ImportForm for uploading other file\n\n    POST-request:\n        * start data importing if data is correct\n\n    \"\"\"\n    if not self.has_import_permission(request):\n        raise PermissionDenied\n\n    job = self.get_import_job(request=request, job_id=job_id)\n    if job.import_status not in self.results_statuses:\n        return self._redirect_to_import_status_page(\n            request=request,\n            job=job,\n        )\n\n    context = self.get_import_context_data()\n\n    if request.method == \"GET\":\n        # GET request, show parse results\n        result = job.result\n        context[\"import_job\"] = job\n        context[\"result\"] = result\n        context[\"title\"] = _(\"Import results\")\n\n        if job.import_status == models.ImportJob.ImportStatus.PARSED:\n            context[\"confirm_form\"] = self.create_confirm_form(request)\n        else:\n            # display import form\n            resource_classes = self.get_import_resource_classes(request)\n            resource_kwargs = self.get_import_resource_kwargs(request)\n\n            context[\"import_form\"] = self.create_import_form(request)\n            context[\"fields_list\"] = self._get_fields_list_for_resources(\n                resource_classes=resource_classes,\n                resource_kwargs=resource_kwargs,\n            )\n\n        context.update(self.admin_site.each_context(request))\n        context[\"opts\"] = self.model_info.meta\n        request.current_app = self.admin_site.name\n        return TemplateResponse(\n            request,\n            [self.import_result_template_name],\n            context,\n        )\n\n    # POST request\n    if job.import_status == models.ImportJob.ImportStatus.PARSED:\n        # start celery task for data importing\n        job.confirm_import()\n        return self._redirect_to_import_status_page(\n            request=request,\n            job=job,\n        )\n\n    return HttpResponseForbidden(\n        \"Data invalid, before importing data \"\n        \"needs to be successfully parsed. \"\n        f\"Current status: {job.import_status}\",\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.celery_import_job_status_view","title":"<code>celery_import_job_status_view(request, job_id, **kwargs)</code>","text":"<p>View to track import job status.</p> <p>Displays current import job status and progress (using JS + another view).</p> <p>If job result is ready - redirects to another page to see results.</p> <p>Also generates admin log entries if the job has <code>IMPORTED</code> status.</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def celery_import_job_status_view(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n    **kwargs,\n) -&gt; HttpResponse:\n    \"\"\"View to track import job status.\n\n    Displays current import job status and progress (using JS + another\n    view).\n\n    If job result is ready - redirects to another page to see results.\n\n    Also generates admin log entries if the job has `IMPORTED` status.\n\n    \"\"\"\n    if not self.has_import_permission(request):\n        raise PermissionDenied\n\n    job = self.get_import_job(request, job_id)\n    if job.import_status in self.results_statuses:\n        if job.import_status == models.ImportJob.ImportStatus.IMPORTED:\n            self.generate_log_entries(job.result, request)\n        return self._redirect_to_results_page(\n            request=request,\n            job=job,\n        )\n\n    context = self.get_import_context_data()\n    job_url = reverse(\"admin:import_job_progress\", args=(job.id,))\n    context.update(\n        {\n            \"title\": _(\"Import status\"),\n            \"opts\": self.model_info.meta,\n            \"import_job\": job,\n            \"import_job_url\": job_url,\n        },\n    )\n    request.current_app = self.admin_site.name\n    return TemplateResponse(\n        request=request,\n        template=[self.import_status_template],\n        context=context,\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.changelist_view","title":"<code>changelist_view(request, context=None)</code>","text":"<p>Add the check for permission to changelist template context.</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def changelist_view(\n    self,\n    request: WSGIRequest,\n    context: dict[str, typing.Any] | None = None,\n) -&gt; HttpResponse:\n    \"\"\"Add the check for permission to changelist template context.\"\"\"\n    context = context or {}\n    context[\"has_import_permission\"] = self.has_import_permission(request)\n    return super().changelist_view(request, context)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.create_import_job","title":"<code>create_import_job(request, form, resource)</code>","text":"<p>Create and return instance of import job.</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def create_import_job(\n    self,\n    request: WSGIRequest,\n    form: Form,\n    resource: types.ResourceObj,\n) -&gt; models.ImportJob:\n    \"\"\"Create and return instance of import job.\"\"\"\n    return models.ImportJob.objects.create(\n        resource_path=resource.class_path,\n        data_file=form.cleaned_data[\"import_file\"],\n        resource_kwargs=resource.resource_init_kwargs,\n        created_by=request.user,\n        skip_parse_step=getattr(\n            settings,\n            \"IMPORT_EXPORT_SKIP_ADMIN_CONFIRM\",\n            False,\n        ),\n        force_import=form.cleaned_data.get(\"force_import\", False),\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.get_import_context_data","title":"<code>get_import_context_data(**kwargs)</code>","text":"<p>Get context data for import.</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def get_import_context_data(self, **kwargs) -&gt; dict[str, typing.Any]:\n    \"\"\"Get context data for import.\"\"\"\n    return self.get_context_data(**kwargs)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.get_import_job","title":"<code>get_import_job(request, job_id)</code>","text":"<p>Get ImportJob instance.</p> <p>Raises     Http404</p> Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def get_import_job(\n    self,\n    request: WSGIRequest,\n    job_id: int,\n) -&gt; models.ImportJob:\n    \"\"\"Get ImportJob instance.\n\n    Raises\n        Http404\n\n    \"\"\"\n    return get_object_or_404(klass=models.ImportJob, id=job_id)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.mixins.import_mixin.CeleryImportAdminMixin.get_urls","title":"<code>get_urls()</code>","text":"<p>Return list of urls.</p> <ul> <li>///:     ImportForm ('celery_import_action' method) <li>////:     status of ImportJob and progress bar     ('celery_import_job_status_view') <li>////results/:     table with import results (errors) and import confirmation     ('celery_import_job_results_view') Source code in <code>import_export_extensions/admin/mixins/import_mixin.py</code> <pre><code>def get_urls(self) -&gt; list[URLPattern]:\n    \"\"\"Return list of urls.\n\n    * /&lt;model&gt;/&lt;celery-import&gt;/:\n        ImportForm ('celery_import_action' method)\n    * /&lt;model&gt;/&lt;celery-import&gt;/&lt;ID&gt;/:\n        status of ImportJob and progress bar\n        ('celery_import_job_status_view')\n    * /&lt;model&gt;/&lt;celery-import&gt;/&lt;ID&gt;/results/:\n        table with import results (errors) and import confirmation\n        ('celery_import_job_results_view')\n\n    \"\"\"\n    urls = super().get_urls()\n    import_urls = [\n        re_path(\n            r\"^celery-import/$\",\n            self.admin_site.admin_view(self.celery_import_action),\n            name=f\"{self.model_info.app_model_name}_import\",\n        ),\n        re_path(\n            r\"^celery-import/(?P&lt;job_id&gt;\\d+)/$\",\n            self.admin_site.admin_view(self.celery_import_job_status_view),\n            name=(\n                f\"{self.model_info.app_model_name}\"\n                f\"_import_job_status\"\n            ),\n        ),\n        re_path(\n            r\"^celery-import/(?P&lt;job_id&gt;\\d+)/results/$\",\n            self.admin_site.admin_view(\n                self.celery_import_job_results_view,\n            ),\n            name=(\n                f\"{self.model_info.app_model_name}\"\n                f\"_import_job_results\"\n            ),\n        ),\n    ]\n    return import_urls + urls\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.widgets.ProgressBarWidget","title":"<code>ProgressBarWidget</code>","text":"<p>               Bases: <code>Widget</code></p> <p>Widget for progress bar field.</p> <p>Value for <code>progress_bar</code> element is changed using JS code.</p> Source code in <code>import_export_extensions/admin/widgets.py</code> <pre><code>class ProgressBarWidget(forms.Widget):\n    \"\"\"Widget for progress bar field.\n\n    Value for `progress_bar` element is changed using JS code.\n\n    \"\"\"\n\n    template_name = \"admin/import_export_extensions/progress_bar.html\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        \"\"\"Get ``ImportJob`` or ``ExportJob`` instance from kwargs.\n\n        ``ImportJob`` or ``ExportJob`` instance is used\n        to render hidden element in `render` method.\n\n        \"\"\"\n        self.job = kwargs.pop(\"job\")\n        self.url = kwargs.pop(\"url\")\n        super().__init__(*args, **kwargs)\n\n    def render(self, *args, **kwargs) -&gt; str:\n        \"\"\"Render HTML5 `progress` element.\n\n        Additionally, method provides hidden `import_job_url` and\n        `export_job_url` value that is used in `js/admin/progress_bar.js`\n        to send GET requests.\n\n        \"\"\"\n        return render_to_string(self.template_name, {\"job_url\": self.url})\n\n    class Media:\n        \"\"\"Class with custom assets for widget.\"\"\"\n\n        css = {\n            \"all\": (\"import_export_extensions/css/widgets/progress_bar.css\",),\n        }\n        js = (\n            \"admin/js/jquery.init.js\",\n            \"import_export_extensions/js/widgets/progress_bar.js\",\n        )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.widgets.ProgressBarWidget.Media","title":"<code>Media</code>","text":"<p>Class with custom assets for widget.</p> Source code in <code>import_export_extensions/admin/widgets.py</code> <pre><code>class Media:\n    \"\"\"Class with custom assets for widget.\"\"\"\n\n    css = {\n        \"all\": (\"import_export_extensions/css/widgets/progress_bar.css\",),\n    }\n    js = (\n        \"admin/js/jquery.init.js\",\n        \"import_export_extensions/js/widgets/progress_bar.js\",\n    )\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.widgets.ProgressBarWidget.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Get <code>ImportJob</code> or <code>ExportJob</code> instance from kwargs.</p> <p><code>ImportJob</code> or <code>ExportJob</code> instance is used to render hidden element in <code>render</code> method.</p> Source code in <code>import_export_extensions/admin/widgets.py</code> <pre><code>def __init__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Get ``ImportJob`` or ``ExportJob`` instance from kwargs.\n\n    ``ImportJob`` or ``ExportJob`` instance is used\n    to render hidden element in `render` method.\n\n    \"\"\"\n    self.job = kwargs.pop(\"job\")\n    self.url = kwargs.pop(\"url\")\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/admin/#import_export_extensions.admin.widgets.ProgressBarWidget.render","title":"<code>render(*args, **kwargs)</code>","text":"<p>Render HTML5 <code>progress</code> element.</p> <p>Additionally, method provides hidden <code>import_job_url</code> and <code>export_job_url</code> value that is used in <code>js/admin/progress_bar.js</code> to send GET requests.</p> Source code in <code>import_export_extensions/admin/widgets.py</code> <pre><code>def render(self, *args, **kwargs) -&gt; str:\n    \"\"\"Render HTML5 `progress` element.\n\n    Additionally, method provides hidden `import_job_url` and\n    `export_job_url` value that is used in `js/admin/progress_bar.js`\n    to send GET requests.\n\n    \"\"\"\n    return render_to_string(self.template_name, {\"job_url\": self.url})\n</code></pre>"},{"location":"reference/drf/","title":"API (Rest Framework)","text":"<p>               Bases: <code>ImportStartActionMixin</code>, <code>BaseImportJobViewSet</code></p> <p>Base API viewset for ImportJob model.</p> <p>Based on resource_class it will generate an endpoint which will allow to start an import to model which was specified in resource_class. On success this endpoint we return an instance of import.</p> Endpoints <ul> <li>list - to get list of all import jobs</li> <li>details(retrieve) - to get status of import job</li> <li>start - create import job and start parsing data from attached file</li> <li>confirm - confirm import after parsing process is finished</li> <li>cancel - stop importing/parsing process and cancel this import job</li> </ul> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>class ImportJobViewSet(\n    core_mixins.ImportStartActionMixin,\n    BaseImportJobViewSet,\n):\n    \"\"\"Base API viewset for ImportJob model.\n\n    Based on resource_class it will generate an endpoint which will allow to\n    start an import to model which was specified in resource_class. On success\n    this endpoint we return an instance of import.\n\n    Endpoints:\n        - list - to get list of all import jobs\n        - details(retrieve) - to get status of import job\n        - start - create import job and start parsing data from attached file\n        - confirm - confirm import after parsing process is finished\n        - cancel - stop importing/parsing process and cancel this import job\n    \"\"\"\n\n    import_action_name = \"start\"\n    import_action_url = \"start\"\n\n    def get_queryset(self) -&gt; QuerySet[models.ImportJob]:\n        \"\"\"Filter import jobs by resource used in viewset.\"\"\"\n        if self.action == getattr(self, \"import_action\", \"\"):\n            # To make it consistent and for better support of drf-spectacular\n            return super().get_queryset()  # pragma: no cover\n        return super().get_queryset().filter(\n            resource_path=self.resource_class.class_path,\n        )\n</code></pre> <p>               Bases: <code>ExportStartActionMixin</code>, <code>BaseExportJobViewSet</code></p> <p>Base API viewset for ExportJob model.</p> <p>Based on resource_class it will generate an endpoint which will allow to start an export of model which was specified in resource_class. This endpoint will support filtration based on FilterSet class specified in resource. On success this endpoint we return an instance of export, to get status of job, just use detail(retrieve) endpoint.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>class ExportJobViewSet(\n    core_mixins.ExportStartActionMixin,\n    BaseExportJobViewSet,\n):\n    \"\"\"Base API viewset for ExportJob model.\n\n    Based on resource_class it will generate an endpoint which will allow to\n    start an export of model which was specified in resource_class. This\n    endpoint will support filtration based on FilterSet class specified in\n    resource. On success this endpoint we return an instance of export, to\n    get status of job, just use detail(retrieve) endpoint.\n\n    \"\"\"\n\n    export_action_name = \"start\"\n    export_action_url = \"start\"\n\n    def get_queryset(self) -&gt; QuerySet[models.ExportJob]:\n        \"\"\"Filter export jobs by resource used in viewset.\"\"\"\n        if self.action == getattr(self, \"export_action\", \"\"):\n            # To make it consistent and for better support of drf-spectacular\n            return super().get_queryset()  # pragma: no cover\n        return super().get_queryset().filter(\n            resource_path=self.resource_class.class_path,\n        )\n</code></pre> <p>               Bases: <code>LimitQuerySetToCurrentUserMixin</code>, <code>ImportJobViewSet</code></p> <p>Viewset for providing import feature to users.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>class ImportJobForUserViewSet(\n    core_mixins.LimitQuerySetToCurrentUserMixin,\n    ImportJobViewSet,\n):\n    \"\"\"Viewset for providing import feature to users.\"\"\"\n</code></pre> <p>               Bases: <code>LimitQuerySetToCurrentUserMixin</code>, <code>ExportJobViewSet</code></p> <p>Viewset for providing export feature to users.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>class ExportJobForUserViewSet(\n    core_mixins.LimitQuerySetToCurrentUserMixin,\n    ExportJobViewSet,\n):\n    \"\"\"Viewset for providing export feature to users.\"\"\"\n</code></pre> <p>               Bases: <code>ListModelMixin</code>, <code>RetrieveModelMixin</code>, <code>GenericViewSet</code></p> <p>Base viewset for managing import jobs.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>class BaseImportJobViewSet(\n    mixins.ListModelMixin,\n    mixins.RetrieveModelMixin,\n    viewsets.GenericViewSet,\n):\n    \"\"\"Base viewset for managing import jobs.\"\"\"\n\n    permission_classes = (permissions.IsAuthenticated,)\n    serializer_class = core_mixins.ImportStartActionMixin.import_detail_serializer_class  # noqa: E501\n    queryset = models.ImportJob.objects.all()\n    search_fields: collections.abc.Sequence[str] = (\"id\",)\n    ordering: collections.abc.Sequence[str] = (\n        \"id\",\n    )\n    ordering_fields: collections.abc.Sequence[str] = (\n        \"id\",\n        \"created\",\n        \"modified\",\n    )\n\n    def __init_subclass__(cls) -&gt; None:\n        \"\"\"Dynamically create an cancel api endpoints.\n\n        Need to do this to enable action and correct open-api spec generated by\n        drf_spectacular.\n\n        \"\"\"\n        super().__init_subclass__()\n        decorators.action(\n            methods=[\"POST\"],\n            detail=True,\n        )(cls.cancel)\n        decorators.action(\n            methods=[\"POST\"],\n            detail=True,\n        )(cls.confirm)\n        # Correct specs of drf-spectacular if it is installed\n        with contextlib.suppress(ImportError):\n            from drf_spectacular.utils import extend_schema, extend_schema_view\n            if hasattr(cls, \"get_import_detail_serializer_class\"):\n                response_serializer = cls().get_import_detail_serializer_class()  # noqa: E501\n            else:\n                response_serializer = cls().get_serializer_class()\n            extend_schema_view(\n                cancel=extend_schema(\n                    request=None,\n                    responses={\n                        status.HTTP_200_OK: response_serializer,\n                    },\n                ),\n                confirm=extend_schema(\n                    request=None,\n                    responses={\n                        status.HTTP_200_OK: response_serializer,\n                    },\n                ),\n            )(cls)\n\n    def confirm(self, *args, **kwargs) -&gt; response.Response:\n        \"\"\"Confirm import job that has `parsed` status.\"\"\"\n        job: models.ImportJob = self.get_object()\n\n        try:\n            job.confirm_import()\n        except ValueError as error:\n            raise exceptions.ValidationError(error.args[0]) from error\n\n        serializer = self.get_serializer(instance=job)\n        return response.Response(\n            status=status.HTTP_200_OK,\n            data=serializer.data,\n        )\n\n    def cancel(self, *args, **kwargs) -&gt; response.Response:\n        \"\"\"Cancel import job that is in progress.\"\"\"\n        job: models.ImportJob = self.get_object()\n\n        try:\n            job.cancel_import()\n        except ValueError as error:\n            raise exceptions.ValidationError(error.args[0]) from error\n\n        serializer = self.get_serializer(instance=job)\n        return response.Response(\n            status=status.HTTP_200_OK,\n            data=serializer.data,\n        )\n</code></pre> <p>               Bases: <code>ListModelMixin</code>, <code>RetrieveModelMixin</code>, <code>GenericViewSet</code></p> <p>Base viewset for managing export jobs.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>class BaseExportJobViewSet(\n    mixins.ListModelMixin,\n    mixins.RetrieveModelMixin,\n    viewsets.GenericViewSet,\n):\n    \"\"\"Base viewset for managing export jobs.\"\"\"\n\n    permission_classes = (permissions.IsAuthenticated,)\n    serializer_class = core_mixins.ExportStartActionMixin.export_detail_serializer_class  # noqa: E501\n    queryset = models.ExportJob.objects.all()\n    filterset_class: django_filters.rest_framework.FilterSet | None = None\n    search_fields: collections.abc.Sequence[str] = (\"id\",)\n    ordering: collections.abc.Sequence[str] = (\n        \"id\",\n    )\n    ordering_fields: collections.abc.Sequence[str] = (\n        \"id\",\n        \"created\",\n        \"modified\",\n    )\n\n    def __init_subclass__(cls) -&gt; None:\n        \"\"\"Dynamically create an cancel api endpoints.\n\n        Need to do this to enable action and correct open-api spec generated by\n        drf_spectacular.\n\n        \"\"\"\n        super().__init_subclass__()\n        decorators.action(\n            methods=[\"POST\"],\n            detail=True,\n        )(cls.cancel)\n        # Correct specs of drf-spectacular if it is installed\n        with contextlib.suppress(ImportError):\n            from drf_spectacular.utils import extend_schema, extend_schema_view\n            if hasattr(cls, \"get_export_detail_serializer_class\"):\n                response_serializer = cls().get_export_detail_serializer_class()  # noqa: E501\n            else:\n                response_serializer = cls().get_serializer_class()\n            extend_schema_view(\n                cancel=extend_schema(\n                    request=None,\n                    responses={\n                        status.HTTP_200_OK: response_serializer,\n                    },\n                ),\n            )(cls)\n\n    def cancel(self, *args, **kwargs) -&gt; response.Response:\n        \"\"\"Cancel export job that is in progress.\"\"\"\n        job: models.ExportJob = self.get_object()\n\n        try:\n            job.cancel_export()\n        except ValueError as error:\n            raise exceptions.ValidationError(error.args[0]) from error\n\n        serializer = self.get_serializer(instance=job)\n        return response.Response(\n            status=status.HTTP_200_OK,\n            data=serializer.data,\n        )\n</code></pre> <p>               Bases: <code>LimitQuerySetToCurrentUserMixin</code>, <code>BaseImportJobViewSet</code></p> <p>Viewset for providing export job management to users.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>class BaseImportJobForUserViewSet(\n    core_mixins.LimitQuerySetToCurrentUserMixin,\n    BaseImportJobViewSet,\n):\n    \"\"\"Viewset for providing export job management to users.\"\"\"\n</code></pre> <p>               Bases: <code>LimitQuerySetToCurrentUserMixin</code>, <code>BaseExportJobViewSet</code></p> <p>Viewset for providing export job management to users.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>class BaseExportJobForUserViewSet(\n    core_mixins.LimitQuerySetToCurrentUserMixin,\n    BaseExportJobViewSet,\n):\n    \"\"\"Viewset for providing export job management to users.\"\"\"\n</code></pre> <p>Make queryset to return only current user jobs.</p> Source code in <code>import_export_extensions/api/mixins/common.py</code> <pre><code>class LimitQuerySetToCurrentUserMixin:\n    \"\"\"Make queryset to return only current user jobs.\"\"\"\n\n    def get_queryset(self) -&gt; QuerySet:\n        \"\"\"Return user's jobs.\"\"\"\n        if self.action in (\n            getattr(self, \"import_action\", \"\"),\n            getattr(self, \"export_action\", \"\"),\n        ):\n            # To make it consistent and for better support of drf-spectacular\n            return (\n                super().get_queryset()  # type: ignore[misc]\n            )  # pragma: no cover\n        return (\n            super()  # type: ignore[misc]\n            .get_queryset()\n            .filter(created_by_id=getattr(self.request.user, \"pk\", None))\n        )\n</code></pre> <p>Mixin which adds start import action.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>class ImportStartActionMixin:\n    \"\"\"Mixin which adds start import action.\"\"\"\n\n    resource_class: type[resources.CeleryModelResource]\n    import_action = \"start_import_action\"\n    import_action_name = \"import\"\n    import_action_url = \"import\"\n    import_detail_serializer_class = serializers.ImportJobSerializer\n    import_open_api_description = (\n        \"This endpoint creates import job and starts it. \"\n        \"To monitor progress use detail endpoint for jobs to fetch state of \"\n        \"job. Once it's status is `PARSED`, you can confirm import and data \"\n        \"should start importing. When status `INPUT_ERROR` or `PARSE_ERROR` \"\n        \"it means data failed validations and can't be imported. \"\n        \"When status is `IMPORTED`, it means data is in system and \"\n        \"job is completed.\"\n    )\n\n    def __init_subclass__(cls) -&gt; None:\n        super().__init_subclass__()\n        # Skip if it is has no resource_class specified\n        if not hasattr(cls, \"resource_class\"):\n            return\n\n        def start_import_action(\n            self: \"ImportStartActionMixin\",\n            request: request.Request,\n            *args,\n            **kwargs,\n        ) -&gt; response.Response:\n            return self.start_import(request)\n\n        setattr(cls, cls.import_action, start_import_action)\n        decorators.action(\n            methods=[\"POST\"],\n            url_name=cls.import_action_name,\n            url_path=cls.import_action_url,\n            detail=False,\n            queryset=cls.resource_class.get_model_queryset(),\n            serializer_class=cls().get_import_create_serializer_class(),\n        )(getattr(cls, cls.import_action))\n        # Correct specs of drf-spectacular if it is installed\n        with contextlib.suppress(ImportError):\n            from drf_spectacular import utils\n\n            utils.extend_schema_view(\n                **{\n                    cls.import_action: utils.extend_schema(\n                        description=cls.import_open_api_description,\n                        filters=True,\n                        responses={\n                            status.HTTP_201_CREATED: cls().get_import_detail_serializer_class(),  # noqa: E501\n                        },\n                    ),\n                },\n            )(cls)\n\n    def get_queryset(self) -&gt; QuerySet:\n        \"\"\"Return import model queryset on import action.\n\n        For better openapi support and consistency.\n\n        \"\"\"\n        if self.action == self.import_action:\n            return self.resource_class.get_model_queryset()  # pragma: no cover\n        return super().get_queryset()  # type: ignore[misc]\n\n    def get_import_detail_serializer_class(\n        self,\n    ) -&gt; type[serializers.ImportJobSerializer]:\n        \"\"\"Get serializer which will be used show details of import job.\"\"\"\n        return self.import_detail_serializer_class\n\n    def get_import_create_serializer_class(self) -&gt; type:\n        \"\"\"Get serializer which will be used to start import job.\"\"\"\n        return serializers.get_create_import_job_serializer(\n            self.resource_class,\n        )\n\n    def get_import_resource_kwargs(self) -&gt; dict[str, typing.Any]:\n        \"\"\"Provide extra arguments to resource class.\"\"\"\n        return {}\n\n    def get_serializer(self, *args, **kwargs) -&gt; Serializer:\n        \"\"\"Provide resource kwargs to serializer class.\"\"\"\n        if self.action == self.import_action:\n            kwargs.setdefault(\n                \"resource_kwargs\",\n                self.get_import_resource_kwargs(),\n            )\n        return super().get_serializer(*args, **kwargs)  # type: ignore[misc]\n\n    def start_import(self, request: request.Request) -&gt; response.Response:\n        \"\"\"Validate request data and start ImportJob.\"\"\"\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n\n        import_job = serializer.save()\n\n        return response.Response(\n            data=self.get_import_detail_serializer_class()(\n                instance=import_job,\n            ).data,\n            status=status.HTTP_201_CREATED,\n        )\n</code></pre> <p>Mixin which adds start export action.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>class ExportStartActionMixin:\n    \"\"\"Mixin which adds start export action.\"\"\"\n\n    resource_class: type[resources.CeleryModelResource]\n    export_action = \"start_export_action\"\n    export_action_name = \"export\"\n    export_action_url = \"export\"\n    export_detail_serializer_class = serializers.ExportJobSerializer\n    export_ordering: collections.abc.Sequence[str] = ()\n    export_ordering_fields: collections.abc.Sequence[str] = ()\n    export_open_api_description = (\n        \"This endpoint creates export job and starts it. \"\n        \"To monitor progress use detail endpoint for jobs to fetch state of \"\n        \"job. Once it's status is `EXPORTED`, you can download file.\"\n    )\n\n    def __init_subclass__(cls) -&gt; None:\n        super().__init_subclass__()\n        # Skip if it is has no resource_class specified\n        if not hasattr(cls, \"resource_class\"):\n            return\n        filter_backends = [\n            module_loading.import_string(\n                settings.DRF_EXPORT_DJANGO_FILTERS_BACKEND,\n            ),\n        ]\n        if cls.export_ordering_fields:\n            filter_backends.append(\n                module_loading.import_string(\n                    settings.DRF_EXPORT_ORDERING_BACKEND,\n                ),\n            )\n\n        def start_export_action(\n            self: \"ExportStartActionMixin\",\n            request: request.Request,\n            *args,\n            **kwargs,\n        ) -&gt; response.Response:\n            return self.start_export(request)\n\n        setattr(cls, cls.export_action, start_export_action)\n        decorators.action(\n            methods=[\"POST\"],\n            url_name=cls.export_action_name,\n            url_path=cls.export_action_url,\n            detail=False,\n            queryset=cls.resource_class.get_model_queryset(),\n            serializer_class=cls().get_export_create_serializer_class(),\n            filterset_class=getattr(\n                cls.resource_class,\n                \"filterset_class\",\n                None,\n            ),\n            filter_backends=filter_backends,\n            ordering=cls.export_ordering,\n            ordering_fields=cls.export_ordering_fields,\n        )(getattr(cls, cls.export_action))\n        # Correct specs of drf-spectacular if it is installed\n        with contextlib.suppress(ImportError):\n            from drf_spectacular import utils\n\n            utils.extend_schema_view(\n                **{\n                    cls.export_action: utils.extend_schema(\n                        description=cls.export_open_api_description,\n                        filters=True,\n                        responses={\n                            status.HTTP_201_CREATED: cls().get_export_detail_serializer_class(),  # noqa: E501\n                        },\n                    ),\n                },\n            )(cls)\n\n    def get_queryset(self) -&gt; QuerySet:\n        \"\"\"Return export model queryset on export action.\n\n        For better openapi support and consistency.\n\n        \"\"\"\n        if self.action == self.export_action:\n            return self.resource_class.get_model_queryset()  # pragma: no cover\n        return super().get_queryset()  # type: ignore[misc]\n\n    def get_export_detail_serializer_class(\n        self,\n    ) -&gt; type[serializers.ExportJobSerializer]:\n        \"\"\"Get serializer which will be used show details of export job.\"\"\"\n        return self.export_detail_serializer_class\n\n    def get_export_create_serializer_class(self) -&gt; type:\n        \"\"\"Get serializer which will be used to start export job.\"\"\"\n        return serializers.get_create_export_job_serializer(\n            self.resource_class,\n        )\n\n    def get_export_resource_kwargs(self) -&gt; dict[str, typing.Any]:\n        \"\"\"Provide extra arguments to resource class.\"\"\"\n        return {}\n\n    def get_serializer(self, *args, **kwargs) -&gt; Serializer:\n        \"\"\"Provide resource kwargs to serializer class.\"\"\"\n        if self.action == self.export_action:\n            kwargs.setdefault(\n                \"resource_kwargs\",\n                self.get_export_resource_kwargs(),\n            )\n        return super().get_serializer(*args, **kwargs)  # type: ignore[misc]\n\n    def start_export(self, request: request.Request) -&gt; response.Response:\n        \"\"\"Validate request data and start ExportJob.\"\"\"\n        ordering = request.query_params.get(\"ordering\", \"\")\n        if ordering:\n            ordering = ordering.split(\",\")\n        serializer = self.get_serializer(\n            data=request.data,\n            ordering=ordering,\n            filter_kwargs=request.query_params,\n        )\n        serializer.is_valid(raise_exception=True)\n        export_job = serializer.save()\n        return response.Response(\n            data=self.get_export_detail_serializer_class()(\n                instance=export_job,\n            ).data,\n            status=status.HTTP_201_CREATED,\n        )\n</code></pre> <p>               Bases: <code>Serializer</code></p> <p>Base Serializer to start export job.</p> <p>It used to set up base workflow of ExportJob creation via API.</p> Source code in <code>import_export_extensions/api/serializers/export_job.py</code> <pre><code>class CreateExportJob(serializers.Serializer):\n    \"\"\"Base Serializer to start export job.\n\n    It used to set up base workflow of ExportJob creation via API.\n\n    \"\"\"\n\n    resource_class: type[resources.CeleryModelResource]\n\n    def __init__(\n        self,\n        *args,\n        ordering: collections.abc.Sequence[str] | None = None,\n        filter_kwargs: dict[str, typing.Any] | None = None,\n        resource_kwargs: dict[str, typing.Any] | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Set ordering, filter kwargs and current user.\"\"\"\n        super().__init__(*args, **kwargs)\n        self._ordering = ordering\n        self._filter_kwargs = filter_kwargs\n        self._resource_kwargs = resource_kwargs or {}\n        self._request: request.Request = self.context.get(\"request\")\n        self._user = getattr(self._request, \"user\", None)\n\n    def validate(self, attrs: dict[str, typing.Any]) -&gt; dict[str, typing.Any]:\n        \"\"\"Check that ordering and filter kwargs are valid.\"\"\"\n        self.resource_class(\n            ordering=self._ordering,\n            filter_kwargs=self._filter_kwargs,\n            created_by=self._user,\n            **self._resource_kwargs,\n        ).get_queryset()\n        return attrs\n\n    def create(\n        self,\n        validated_data: dict[str, typing.Any],\n    ) -&gt; models.ExportJob:\n        \"\"\"Create export job.\"\"\"\n        file_format_class = self.resource_class.get_supported_extensions_map()[\n            validated_data[\"file_format\"]\n        ]\n        return models.ExportJob.objects.create(\n            resource_path=self.resource_class.class_path,\n            file_format_path=f\"{file_format_class.__module__}.{file_format_class.__name__}\",\n            resource_kwargs={\n                \"ordering\": self._ordering,\n                \"filter_kwargs\": self._filter_kwargs,\n                **self._resource_kwargs,\n            },\n            created_by=self._user,\n        )\n\n    def update(self, instance, validated_data) -&gt; None:\n        \"\"\"Empty method to pass linters checks.\"\"\"\n</code></pre> <p>               Bases: <code>Serializer</code></p> <p>Base Serializer to start import job.</p> <p>It used to set up base workflow of ImportJob creation via API.</p> Source code in <code>import_export_extensions/api/serializers/import_job.py</code> <pre><code>class CreateImportJob(serializers.Serializer):\n    \"\"\"Base Serializer to start import job.\n\n    It used to set up base workflow of ImportJob creation via API.\n\n    \"\"\"\n\n    resource_class: type[resources.CeleryModelResource]\n\n    file = serializers.FileField(required=True)\n    force_import = serializers.BooleanField(default=False, required=False)\n    skip_parse_step = serializers.BooleanField(default=False, required=False)\n\n    def __init__(\n        self,\n        *args,\n        resource_kwargs: dict[str, typing.Any] | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Set filter kwargs and current user.\"\"\"\n        super().__init__(*args, **kwargs)\n        self._request: request.Request = self.context.get(\"request\")\n        self._resource_kwargs = resource_kwargs or {}\n        self._user = getattr(self._request, \"user\", None)\n\n    def create(\n        self,\n        validated_data: dict[str, typing.Any],\n    ) -&gt; models.ImportJob:\n        \"\"\"Create import job.\"\"\"\n        return models.ImportJob.objects.create(\n            data_file=validated_data[\"file\"],\n            force_import=validated_data[\"force_import\"],\n            skip_parse_step=validated_data[\"skip_parse_step\"],\n            resource_path=self.resource_class.class_path,\n            resource_kwargs=self._resource_kwargs,\n            created_by=self._user,\n        )\n\n    def update(self, instance, validated_data) -&gt; None:\n        \"\"\"Empty method to pass linters checks.\"\"\"\n</code></pre> <p>               Bases: <code>ModelSerializer</code></p> <p>Serializer to show information about export job.</p> Source code in <code>import_export_extensions/api/serializers/export_job.py</code> <pre><code>class ExportJobSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer to show information about export job.\"\"\"\n\n    progress = ExportProgressSerializer()\n\n    class Meta:\n        model = models.ExportJob\n        fields = (\n            \"id\",\n            \"export_status\",\n            \"data_file\",\n            \"progress\",\n            \"export_started\",\n            \"export_finished\",\n            \"created\",\n            \"modified\",\n        )\n</code></pre> <p>               Bases: <code>ModelSerializer</code></p> <p>Serializer to show information about import job.</p> Source code in <code>import_export_extensions/api/serializers/import_job.py</code> <pre><code>class ImportJobSerializer(serializers.ModelSerializer):\n    \"\"\"Serializer to show information about import job.\"\"\"\n\n    progress = ImportProgressSerializer()\n\n    import_params = details.ImportParamsSerializer(\n        read_only=True,\n        source=\"*\",\n    )\n    totals = details.TotalsSerializer(\n        read_only=True,\n        source=\"*\",\n    )\n    parse_error = serializers.CharField(\n        source=\"error_message\",\n        read_only=True,\n        allow_blank=True,\n    )\n    input_error = details.InputErrorSerializer(\n        source=\"*\",\n        read_only=True,\n    )\n    skipped_errors = details.SkippedErrorsSerializer(\n        source=\"*\",\n        read_only=True,\n    )\n    importing_data = details.ImportingDataSerializer(\n        read_only=True,\n        source=\"*\",\n    )\n    input_errors_file = serializers.FileField(\n        read_only=True,\n        allow_null=True,\n    )\n    is_all_rows_shown = details.IsAllRowsShowField(\n        source=\"*\",\n        read_only=True,\n    )\n\n    class Meta:\n        model = models.ImportJob\n        fields = (\n            \"id\",\n            \"progress\",\n            \"import_status\",\n            \"import_params\",\n            \"totals\",\n            \"parse_error\",\n            \"input_error\",\n            \"skipped_errors\",\n            \"is_all_rows_shown\",\n            \"importing_data\",\n            \"input_errors_file\",\n            \"import_started\",\n            \"import_finished\",\n            \"force_import\",\n            \"created\",\n            \"modified\",\n        )\n</code></pre> <p>               Bases: <code>Serializer</code></p> <p>Serializer to show progress of job.</p> Source code in <code>import_export_extensions/api/serializers/progress.py</code> <pre><code>class ProgressSerializer(serializers.Serializer):\n    \"\"\"Serializer to show progress of job.\"\"\"\n\n    info = ProgressInfoSerializer()\n</code></pre> <p>               Bases: <code>Serializer</code></p> <p>Serializer to show progress info, like how much is done.</p> Source code in <code>import_export_extensions/api/serializers/progress.py</code> <pre><code>class ProgressInfoSerializer(serializers.Serializer):\n    \"\"\"Serializer to show progress info, like how much is done.\"\"\"\n\n    current = serializers.IntegerField()\n    total = serializers.IntegerField()\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportJobViewSet.get_queryset","title":"<code>get_queryset()</code>","text":"<p>Filter import jobs by resource used in viewset.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>def get_queryset(self) -&gt; QuerySet[models.ImportJob]:\n    \"\"\"Filter import jobs by resource used in viewset.\"\"\"\n    if self.action == getattr(self, \"import_action\", \"\"):\n        # To make it consistent and for better support of drf-spectacular\n        return super().get_queryset()  # pragma: no cover\n    return super().get_queryset().filter(\n        resource_path=self.resource_class.class_path,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportJobViewSet.get_queryset","title":"<code>get_queryset()</code>","text":"<p>Filter export jobs by resource used in viewset.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>def get_queryset(self) -&gt; QuerySet[models.ExportJob]:\n    \"\"\"Filter export jobs by resource used in viewset.\"\"\"\n    if self.action == getattr(self, \"export_action\", \"\"):\n        # To make it consistent and for better support of drf-spectacular\n        return super().get_queryset()  # pragma: no cover\n    return super().get_queryset().filter(\n        resource_path=self.resource_class.class_path,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.BaseImportJobViewSet.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Dynamically create an cancel api endpoints.</p> <p>Need to do this to enable action and correct open-api spec generated by drf_spectacular.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n    \"\"\"Dynamically create an cancel api endpoints.\n\n    Need to do this to enable action and correct open-api spec generated by\n    drf_spectacular.\n\n    \"\"\"\n    super().__init_subclass__()\n    decorators.action(\n        methods=[\"POST\"],\n        detail=True,\n    )(cls.cancel)\n    decorators.action(\n        methods=[\"POST\"],\n        detail=True,\n    )(cls.confirm)\n    # Correct specs of drf-spectacular if it is installed\n    with contextlib.suppress(ImportError):\n        from drf_spectacular.utils import extend_schema, extend_schema_view\n        if hasattr(cls, \"get_import_detail_serializer_class\"):\n            response_serializer = cls().get_import_detail_serializer_class()  # noqa: E501\n        else:\n            response_serializer = cls().get_serializer_class()\n        extend_schema_view(\n            cancel=extend_schema(\n                request=None,\n                responses={\n                    status.HTTP_200_OK: response_serializer,\n                },\n            ),\n            confirm=extend_schema(\n                request=None,\n                responses={\n                    status.HTTP_200_OK: response_serializer,\n                },\n            ),\n        )(cls)\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.BaseImportJobViewSet.cancel","title":"<code>cancel(*args, **kwargs)</code>","text":"<p>Cancel import job that is in progress.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>def cancel(self, *args, **kwargs) -&gt; response.Response:\n    \"\"\"Cancel import job that is in progress.\"\"\"\n    job: models.ImportJob = self.get_object()\n\n    try:\n        job.cancel_import()\n    except ValueError as error:\n        raise exceptions.ValidationError(error.args[0]) from error\n\n    serializer = self.get_serializer(instance=job)\n    return response.Response(\n        status=status.HTTP_200_OK,\n        data=serializer.data,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.BaseImportJobViewSet.confirm","title":"<code>confirm(*args, **kwargs)</code>","text":"<p>Confirm import job that has <code>parsed</code> status.</p> Source code in <code>import_export_extensions/api/views/import_job.py</code> <pre><code>def confirm(self, *args, **kwargs) -&gt; response.Response:\n    \"\"\"Confirm import job that has `parsed` status.\"\"\"\n    job: models.ImportJob = self.get_object()\n\n    try:\n        job.confirm_import()\n    except ValueError as error:\n        raise exceptions.ValidationError(error.args[0]) from error\n\n    serializer = self.get_serializer(instance=job)\n    return response.Response(\n        status=status.HTTP_200_OK,\n        data=serializer.data,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.BaseExportJobViewSet.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Dynamically create an cancel api endpoints.</p> <p>Need to do this to enable action and correct open-api spec generated by drf_spectacular.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n    \"\"\"Dynamically create an cancel api endpoints.\n\n    Need to do this to enable action and correct open-api spec generated by\n    drf_spectacular.\n\n    \"\"\"\n    super().__init_subclass__()\n    decorators.action(\n        methods=[\"POST\"],\n        detail=True,\n    )(cls.cancel)\n    # Correct specs of drf-spectacular if it is installed\n    with contextlib.suppress(ImportError):\n        from drf_spectacular.utils import extend_schema, extend_schema_view\n        if hasattr(cls, \"get_export_detail_serializer_class\"):\n            response_serializer = cls().get_export_detail_serializer_class()  # noqa: E501\n        else:\n            response_serializer = cls().get_serializer_class()\n        extend_schema_view(\n            cancel=extend_schema(\n                request=None,\n                responses={\n                    status.HTTP_200_OK: response_serializer,\n                },\n            ),\n        )(cls)\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.BaseExportJobViewSet.cancel","title":"<code>cancel(*args, **kwargs)</code>","text":"<p>Cancel export job that is in progress.</p> Source code in <code>import_export_extensions/api/views/export_job.py</code> <pre><code>def cancel(self, *args, **kwargs) -&gt; response.Response:\n    \"\"\"Cancel export job that is in progress.\"\"\"\n    job: models.ExportJob = self.get_object()\n\n    try:\n        job.cancel_export()\n    except ValueError as error:\n        raise exceptions.ValidationError(error.args[0]) from error\n\n    serializer = self.get_serializer(instance=job)\n    return response.Response(\n        status=status.HTTP_200_OK,\n        data=serializer.data,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.LimitQuerySetToCurrentUserMixin.get_queryset","title":"<code>get_queryset()</code>","text":"<p>Return user's jobs.</p> Source code in <code>import_export_extensions/api/mixins/common.py</code> <pre><code>def get_queryset(self) -&gt; QuerySet:\n    \"\"\"Return user's jobs.\"\"\"\n    if self.action in (\n        getattr(self, \"import_action\", \"\"),\n        getattr(self, \"export_action\", \"\"),\n    ):\n        # To make it consistent and for better support of drf-spectacular\n        return (\n            super().get_queryset()  # type: ignore[misc]\n        )  # pragma: no cover\n    return (\n        super()  # type: ignore[misc]\n        .get_queryset()\n        .filter(created_by_id=getattr(self.request.user, \"pk\", None))\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportStartActionMixin.get_import_create_serializer_class","title":"<code>get_import_create_serializer_class()</code>","text":"<p>Get serializer which will be used to start import job.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>def get_import_create_serializer_class(self) -&gt; type:\n    \"\"\"Get serializer which will be used to start import job.\"\"\"\n    return serializers.get_create_import_job_serializer(\n        self.resource_class,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportStartActionMixin.get_import_detail_serializer_class","title":"<code>get_import_detail_serializer_class()</code>","text":"<p>Get serializer which will be used show details of import job.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>def get_import_detail_serializer_class(\n    self,\n) -&gt; type[serializers.ImportJobSerializer]:\n    \"\"\"Get serializer which will be used show details of import job.\"\"\"\n    return self.import_detail_serializer_class\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportStartActionMixin.get_import_resource_kwargs","title":"<code>get_import_resource_kwargs()</code>","text":"<p>Provide extra arguments to resource class.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>def get_import_resource_kwargs(self) -&gt; dict[str, typing.Any]:\n    \"\"\"Provide extra arguments to resource class.\"\"\"\n    return {}\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportStartActionMixin.get_queryset","title":"<code>get_queryset()</code>","text":"<p>Return import model queryset on import action.</p> <p>For better openapi support and consistency.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>def get_queryset(self) -&gt; QuerySet:\n    \"\"\"Return import model queryset on import action.\n\n    For better openapi support and consistency.\n\n    \"\"\"\n    if self.action == self.import_action:\n        return self.resource_class.get_model_queryset()  # pragma: no cover\n    return super().get_queryset()  # type: ignore[misc]\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportStartActionMixin.get_serializer","title":"<code>get_serializer(*args, **kwargs)</code>","text":"<p>Provide resource kwargs to serializer class.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>def get_serializer(self, *args, **kwargs) -&gt; Serializer:\n    \"\"\"Provide resource kwargs to serializer class.\"\"\"\n    if self.action == self.import_action:\n        kwargs.setdefault(\n            \"resource_kwargs\",\n            self.get_import_resource_kwargs(),\n        )\n    return super().get_serializer(*args, **kwargs)  # type: ignore[misc]\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ImportStartActionMixin.start_import","title":"<code>start_import(request)</code>","text":"<p>Validate request data and start ImportJob.</p> Source code in <code>import_export_extensions/api/mixins/import_mixins.py</code> <pre><code>def start_import(self, request: request.Request) -&gt; response.Response:\n    \"\"\"Validate request data and start ImportJob.\"\"\"\n    serializer = self.get_serializer(data=request.data)\n    serializer.is_valid(raise_exception=True)\n\n    import_job = serializer.save()\n\n    return response.Response(\n        data=self.get_import_detail_serializer_class()(\n            instance=import_job,\n        ).data,\n        status=status.HTTP_201_CREATED,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportStartActionMixin.get_export_create_serializer_class","title":"<code>get_export_create_serializer_class()</code>","text":"<p>Get serializer which will be used to start export job.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>def get_export_create_serializer_class(self) -&gt; type:\n    \"\"\"Get serializer which will be used to start export job.\"\"\"\n    return serializers.get_create_export_job_serializer(\n        self.resource_class,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportStartActionMixin.get_export_detail_serializer_class","title":"<code>get_export_detail_serializer_class()</code>","text":"<p>Get serializer which will be used show details of export job.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>def get_export_detail_serializer_class(\n    self,\n) -&gt; type[serializers.ExportJobSerializer]:\n    \"\"\"Get serializer which will be used show details of export job.\"\"\"\n    return self.export_detail_serializer_class\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportStartActionMixin.get_export_resource_kwargs","title":"<code>get_export_resource_kwargs()</code>","text":"<p>Provide extra arguments to resource class.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>def get_export_resource_kwargs(self) -&gt; dict[str, typing.Any]:\n    \"\"\"Provide extra arguments to resource class.\"\"\"\n    return {}\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportStartActionMixin.get_queryset","title":"<code>get_queryset()</code>","text":"<p>Return export model queryset on export action.</p> <p>For better openapi support and consistency.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>def get_queryset(self) -&gt; QuerySet:\n    \"\"\"Return export model queryset on export action.\n\n    For better openapi support and consistency.\n\n    \"\"\"\n    if self.action == self.export_action:\n        return self.resource_class.get_model_queryset()  # pragma: no cover\n    return super().get_queryset()  # type: ignore[misc]\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportStartActionMixin.get_serializer","title":"<code>get_serializer(*args, **kwargs)</code>","text":"<p>Provide resource kwargs to serializer class.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>def get_serializer(self, *args, **kwargs) -&gt; Serializer:\n    \"\"\"Provide resource kwargs to serializer class.\"\"\"\n    if self.action == self.export_action:\n        kwargs.setdefault(\n            \"resource_kwargs\",\n            self.get_export_resource_kwargs(),\n        )\n    return super().get_serializer(*args, **kwargs)  # type: ignore[misc]\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.ExportStartActionMixin.start_export","title":"<code>start_export(request)</code>","text":"<p>Validate request data and start ExportJob.</p> Source code in <code>import_export_extensions/api/mixins/export_mixins.py</code> <pre><code>def start_export(self, request: request.Request) -&gt; response.Response:\n    \"\"\"Validate request data and start ExportJob.\"\"\"\n    ordering = request.query_params.get(\"ordering\", \"\")\n    if ordering:\n        ordering = ordering.split(\",\")\n    serializer = self.get_serializer(\n        data=request.data,\n        ordering=ordering,\n        filter_kwargs=request.query_params,\n    )\n    serializer.is_valid(raise_exception=True)\n    export_job = serializer.save()\n    return response.Response(\n        data=self.get_export_detail_serializer_class()(\n            instance=export_job,\n        ).data,\n        status=status.HTTP_201_CREATED,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateExportJob.__init__","title":"<code>__init__(*args, ordering=None, filter_kwargs=None, resource_kwargs=None, **kwargs)</code>","text":"<p>Set ordering, filter kwargs and current user.</p> Source code in <code>import_export_extensions/api/serializers/export_job.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    ordering: collections.abc.Sequence[str] | None = None,\n    filter_kwargs: dict[str, typing.Any] | None = None,\n    resource_kwargs: dict[str, typing.Any] | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Set ordering, filter kwargs and current user.\"\"\"\n    super().__init__(*args, **kwargs)\n    self._ordering = ordering\n    self._filter_kwargs = filter_kwargs\n    self._resource_kwargs = resource_kwargs or {}\n    self._request: request.Request = self.context.get(\"request\")\n    self._user = getattr(self._request, \"user\", None)\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateExportJob.create","title":"<code>create(validated_data)</code>","text":"<p>Create export job.</p> Source code in <code>import_export_extensions/api/serializers/export_job.py</code> <pre><code>def create(\n    self,\n    validated_data: dict[str, typing.Any],\n) -&gt; models.ExportJob:\n    \"\"\"Create export job.\"\"\"\n    file_format_class = self.resource_class.get_supported_extensions_map()[\n        validated_data[\"file_format\"]\n    ]\n    return models.ExportJob.objects.create(\n        resource_path=self.resource_class.class_path,\n        file_format_path=f\"{file_format_class.__module__}.{file_format_class.__name__}\",\n        resource_kwargs={\n            \"ordering\": self._ordering,\n            \"filter_kwargs\": self._filter_kwargs,\n            **self._resource_kwargs,\n        },\n        created_by=self._user,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateExportJob.update","title":"<code>update(instance, validated_data)</code>","text":"<p>Empty method to pass linters checks.</p> Source code in <code>import_export_extensions/api/serializers/export_job.py</code> <pre><code>def update(self, instance, validated_data) -&gt; None:\n    \"\"\"Empty method to pass linters checks.\"\"\"\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateExportJob.validate","title":"<code>validate(attrs)</code>","text":"<p>Check that ordering and filter kwargs are valid.</p> Source code in <code>import_export_extensions/api/serializers/export_job.py</code> <pre><code>def validate(self, attrs: dict[str, typing.Any]) -&gt; dict[str, typing.Any]:\n    \"\"\"Check that ordering and filter kwargs are valid.\"\"\"\n    self.resource_class(\n        ordering=self._ordering,\n        filter_kwargs=self._filter_kwargs,\n        created_by=self._user,\n        **self._resource_kwargs,\n    ).get_queryset()\n    return attrs\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateImportJob.__init__","title":"<code>__init__(*args, resource_kwargs=None, **kwargs)</code>","text":"<p>Set filter kwargs and current user.</p> Source code in <code>import_export_extensions/api/serializers/import_job.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    resource_kwargs: dict[str, typing.Any] | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Set filter kwargs and current user.\"\"\"\n    super().__init__(*args, **kwargs)\n    self._request: request.Request = self.context.get(\"request\")\n    self._resource_kwargs = resource_kwargs or {}\n    self._user = getattr(self._request, \"user\", None)\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateImportJob.create","title":"<code>create(validated_data)</code>","text":"<p>Create import job.</p> Source code in <code>import_export_extensions/api/serializers/import_job.py</code> <pre><code>def create(\n    self,\n    validated_data: dict[str, typing.Any],\n) -&gt; models.ImportJob:\n    \"\"\"Create import job.\"\"\"\n    return models.ImportJob.objects.create(\n        data_file=validated_data[\"file\"],\n        force_import=validated_data[\"force_import\"],\n        skip_parse_step=validated_data[\"skip_parse_step\"],\n        resource_path=self.resource_class.class_path,\n        resource_kwargs=self._resource_kwargs,\n        created_by=self._user,\n    )\n</code></pre>"},{"location":"reference/drf/#import_export_extensions.api.CreateImportJob.update","title":"<code>update(instance, validated_data)</code>","text":"<p>Empty method to pass linters checks.</p> Source code in <code>import_export_extensions/api/serializers/import_job.py</code> <pre><code>def update(self, instance, validated_data) -&gt; None:\n    \"\"\"Empty method to pass linters checks.\"\"\"\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>               Bases: <code>BaseJob</code></p> <p>Abstract model for managing celery export jobs.</p> <p>Encapsulate all logic related to celery export.</p> <p>Export steps:</p> <ol> <li>Create <code>ExportJob</code> with resource initialization parameters.</li> <li>Try to export all data to file.</li> <li>If everything is correct - export data to file from database.</li> </ol> <p>Export file saves in media files.</p> Source code in <code>import_export_extensions/models/export_job.py</code> <pre><code>class ExportJob(BaseJob):\n    \"\"\"Abstract model for managing celery export jobs.\n\n    Encapsulate all logic related to celery export.\n\n    Export steps:\n\n    1. Create ``ExportJob`` with resource initialization parameters.\n    2. Try to export all data to file.\n    3. If everything is correct - export data to file from database.\n\n    Export file saves in media files.\n\n    \"\"\"\n\n    class ExportStatus(models.TextChoices):\n        \"\"\"ExportJob possible statuses.\n\n        * CREATED:\n            export job is just created, no exporting done\n        * EXPORTING:\n            export job started\n        * EXPORT_ERROR:\n            DB queryset not exported, errors\n        * EXPORTED:\n            DB queryset exported, no errors occurred\n\n        State diagrams:\n\n            CREATED\n               |\n            EXPORTING  - (EXPORT_ERROR)\n               |\n            EXPORTED\n\n        \"\"\"\n\n        CREATED = \"CREATED\", _(\"Created\")\n        EXPORTING = \"EXPORTING\", _(\"Exporting\")\n        EXPORT_ERROR = \"EXPORT_ERROR\", _(\"Export Error\")\n        EXPORTED = \"EXPORTED\", _(\"Exported\")\n        CANCELLED = \"CANCELLED\", _(\"Cancelled\")\n\n    export_finished_statuses = (\n        ExportStatus.EXPORTED,\n        ExportStatus.EXPORT_ERROR,\n    )\n\n    export_status = models.CharField(\n        max_length=20,\n        choices=ExportStatus.choices,\n        default=ExportStatus.CREATED,\n        verbose_name=_(\"Job status\"),\n    )\n\n    file_format_path = models.CharField(\n        max_length=128,\n        verbose_name=_(\"Export path to class\"),\n        help_text=_(\n            \"Export file format as path to base_formats class\",\n        ),\n    )\n\n    data_file = models.FileField(\n        max_length=512,\n        storage=tools.select_storage,\n        verbose_name=_(\"Data file\"),\n        upload_to=tools.upload_export_file_to,\n        help_text=_(\"File that contain exported data\"),\n    )\n\n    export_task_id = models.CharField(  # noqa: DJ001\n        verbose_name=_(\"Export task ID\"),\n        max_length=36,\n        null=True,\n        blank=True,\n        help_text=_(\"Celery task ID that start `export_data`\"),\n    )\n\n    export_started = models.DateTimeField(\n        verbose_name=_(\"Export started\"),\n        editable=False,\n        blank=True,\n        null=True,\n    )\n\n    export_finished = models.DateTimeField(\n        verbose_name=_(\"Export finished\"),\n        editable=False,\n        blank=True,\n        null=True,\n    )\n\n    class Meta:\n        verbose_name = _(\"Export job\")\n        verbose_name_plural = _(\"Export jobs\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation.\"\"\"\n        resource_name = pathlib.Path(self.resource_path).suffix.lstrip(\".\")\n        file_format = pathlib.Path(self.file_format_path).suffix.lstrip(\".\")\n\n        return f\"ExportJob(resource={resource_name}, {file_format=})\"\n\n    def save(\n        self,\n        force_insert: bool = False,\n        force_update: bool = False,\n        using: str | None = None,\n        update_fields: collections.abc.Iterable[str] | None = None,\n    ) -&gt; None:\n        \"\"\"Start task for data exporting when ExportJob is created.\n\n        Celery task is manually called with `apply_async`, to provide\n        possibility of custom `task_id` with which task will be run.\n\n        \"\"\"\n        is_created = self._state.adding\n        super().save(\n            force_insert=force_insert,\n            force_update=force_update,\n            using=using,\n            update_fields=update_fields,\n        )\n        if is_created:\n            self.export_task_id = str(uuid.uuid4())\n            self.save(update_fields=[\"export_task_id\"])\n            transaction.on_commit(self._start_export_data_task)\n\n    @property\n    def file_format(self) -&gt; base_formats.Format:\n        \"\"\"Get initialized format instance.\"\"\"\n        return module_loading.import_string(self.file_format_path)()\n\n    @property\n    def export_filename(self) -&gt; str:\n        \"\"\"Get filename for export result file.\"\"\"\n        return self.resource.generate_export_filename(\n            file_format=self.file_format,\n        ).replace(\"/\", \"-\")\n\n    @property\n    def progress(self) -&gt; TaskStateInfo | None:\n        \"\"\"Return dict with export state.\"\"\"\n        if (\n            self.export_task_id\n            and self.export_status == self.ExportStatus.EXPORTING\n        ):\n            return self._get_task_state(self.export_task_id)\n\n        return None\n\n    def _check_export_status_correctness(\n        self,\n        expected_statuses: collections.abc.Sequence[ExportStatus],\n    ) -&gt; None:\n        \"\"\"Raise `ValueError` if `ExportJob` is in incorrect state.\"\"\"\n        if self.export_status not in expected_statuses:\n            raise ValueError(\n                f\"ExportJob with id {self.id} has incorrect status: \"\n                f\"`{self.export_status}`. Expected statuses:\"\n                f\" {[status.value for status in expected_statuses]}\",\n            )\n\n    def _start_export_data_task(self) -&gt; None:\n        \"\"\"Start export data task.\"\"\"\n        from .. import tasks\n\n        tasks.export_data_task.apply_async(\n            kwargs={\"job_id\": self.pk},\n            task_id=self.export_task_id,\n        )\n\n    def export_data(self) -&gt; None:\n        \"\"\"Export data to `data_file` from DB.\"\"\"\n        self.export_status = self.ExportStatus.EXPORTING\n        self.export_started = timezone.now()\n        self.save(\n            update_fields=[\n                \"export_status\",\n                \"export_started\",\n            ],\n        )\n        try:\n            self._export_data_inner()\n            self.export_status = self.ExportStatus.EXPORTED\n            self.export_finished = timezone.now()\n            self.save(\n                update_fields=[\n                    \"export_status\",\n                    \"export_finished\",\n                ],\n            )\n        except Exception as error:\n            self._handle_error(\n                error_message=str(error),\n                traceback=traceback.format_exc(),\n                exception=error,\n            )\n\n    def cancel_export(self) -&gt; None:\n        \"\"\"Cancel current data export.\n\n        ExportJob can be CANCELLED only from following states:\n            - CREATED\n            - EXPORTING\n\n        \"\"\"\n        self._check_export_status_correctness(\n            expected_statuses=(  # type: ignore\n                self.ExportStatus.CREATED,\n                self.ExportStatus.EXPORTING,\n            ),\n        )\n\n        # send signal to celery to revoke task\n        current_app.control.revoke(self.export_task_id, terminate=True)\n\n        self.export_status = self.ExportStatus.CANCELLED\n        self.save(update_fields=[\"export_status\"])\n\n    def _export_data_inner(self) -&gt; None:\n        \"\"\"Run export process with saving to file.\"\"\"\n        self.result = self.resource.export(**self.resource_kwargs)\n        self.save(update_fields=[\"result\"])\n\n        # `export_data` may be bytes (base formats such as xlsx, csv, etc.) or\n        # file object (formats inherited from `BaseZipExport`)\n        export_data = self.file_format.export_data(\n            dataset=self.result,\n            **self.resource.get_export_data_format_kwargs(\n                file_format=self.file_format,\n            ),\n        )\n        # create file if `export_data` is not file\n        if not hasattr(export_data, \"read\"):\n            export_data = django_files.base.ContentFile(\n                content=encoding.force_bytes(export_data),\n            )\n        self.data_file.save(\n            name=self.export_filename,\n            content=export_data,\n            save=True,\n        )\n\n    def _get_task_state(self, task_id: str) -&gt; TaskStateInfo:\n        \"\"\"Get state info for passed task_id.\n\n        This method may change job status if task failed, but we did not\n        save info about this to DB.\n\n        This may happen if task start exporting, but processes was killed.\n        In that case, job have status `importing`, but it can't be finished.\n\n        \"\"\"\n        async_result = result.AsyncResult(task_id)\n        if async_result.state not in states.EXCEPTION_STATES:\n            return {\n                \"state\": async_result.state,\n                \"info\": async_result.info,\n            }\n\n        self._handle_error(\n            error_message=str(async_result.info),\n            traceback=str(async_result.traceback),\n        )\n        return {\n            \"state\": async_result.state,\n            \"info\": {},\n        }\n\n    def _handle_error(\n        self,\n        error_message: str,\n        traceback: str,\n        exception: Exception | None = None,\n    ) -&gt; None:\n        \"\"\"Update job's status in case of error.\"\"\"\n        self.export_status = self.ExportStatus.EXPORT_ERROR\n        error_message_limit = self._meta.get_field(\"error_message\").max_length\n        self.error_message = error_message[:error_message_limit]\n        self.traceback = traceback\n        self.save(\n            update_fields=[\n                \"error_message\",\n                \"traceback\",\n                \"export_status\",\n            ],\n        )\n        signals.export_job_failed.send(\n            sender=self.__class__,\n            instance=self,\n            error_message=self.error_message,\n            traceback=self.traceback,\n            exception=exception,\n        )\n</code></pre> <p>               Bases: <code>BaseJob</code></p> <p>Abstract model for managing celery import jobs.</p> <p>Encapsulate all logic related to celery import.</p> <p>Import steps:</p> <ol> <li>Create <code>ImportJob</code> with resource initialization parameters and file     with data to be imported from.</li> <li>Dry run. Try to import all data from file and collect statistics (     errors, new rows, updated rows).</li> <li>If data for import is correct - import data from file to database.</li> </ol> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>class ImportJob(BaseJob):\n    \"\"\"Abstract model for managing celery import jobs.\n\n    Encapsulate all logic related to celery import.\n\n    Import steps:\n\n    1. Create ``ImportJob`` with resource initialization parameters and file\n        with data to be imported from.\n    2. Dry run. Try to import all data from file and collect statistics (\n        errors, new rows, updated rows).\n    3. If data for import is correct - import data from file to database.\n\n    \"\"\"\n\n    class ImportStatus(models.TextChoices):\n        \"\"\"ImportJob possible statuses.\n\n        * CREATED:\n            import job is just created, no parsing done\n        * PARSING:\n            parse job started\n        * PARSED:\n            data_file parsed, no errors in data occurred\n        * INPUT_ERROR:\n            data_file parsed, data contains errors\n        * PARSE_ERROR:\n            data_file can't be parsed (invalid format, etc.)\n        * IMPORT_CONFIRMED\n            import confirmed but not started yet\n        * IMPORTING:\n            importing job started\n        * IMPORTED:\n            data from data_file imported to DB w/o errors\n        * IMPORT_ERROR:\n            unknown error during import\n        * CANCELLED:\n            import job has been cancelled (revoked)\n\n        State diagrams:\n\n            CREATED\n               |\n            .parse_data()\n               |\n            PARSING  - (INPUT_ERROR, PARSE_ERROR)\n               |\n            PARSED\n               |\n            .confirm_import()\n               |\n            IMPORT_CONFIRMED\n               |\n            .import_data()\n               |\n            IMPORTING - IMPORT_ERROR\n               |\n            IMPORTED\n\n        \"\"\"\n\n        CREATED = \"CREATED\", _(\"Created\")\n        PARSING = \"PARSING\", _(\"Parsing\")\n        PARSED = \"PARSED\", _(\"Parsed\")\n        INPUT_ERROR = \"INPUT_ERROR\", _(\"Input data error\")\n        PARSE_ERROR = \"PARSE_ERROR\", _(\"Parse error\")\n        CONFIRMED = \"CONFIRMED\", _(\"Import confirmed\")\n        IMPORTING = \"IMPORTING\", _(\"Importing\")\n        IMPORTED = \"IMPORTED\", _(\"Imported\")\n        IMPORT_ERROR = \"IMPORT_ERROR\", _(\"Import error\")\n        CANCELLED = \"CANCELLED\", _(\"Cancelled\")\n\n    results_statuses = (\n        ImportStatus.PARSED,\n        ImportStatus.INPUT_ERROR,\n        ImportStatus.IMPORTED,\n        ImportStatus.IMPORT_ERROR,\n    )\n\n    progress_statuses = (\n        ImportStatus.PARSING,\n        ImportStatus.IMPORTING,\n    )\n\n    parse_finished_statuses = (\n        ImportStatus.INPUT_ERROR,\n        ImportStatus.PARSE_ERROR,\n        ImportStatus.PARSED,\n    )\n\n    import_finished_statuses = (\n        ImportStatus.IMPORTED,\n        ImportStatus.IMPORT_ERROR,\n    )\n\n    success_statuses = (\n        ImportStatus.IMPORTED,\n        ImportStatus.PARSED,\n    )\n\n    failure_statuses = (\n        ImportStatus.INPUT_ERROR,\n        ImportStatus.PARSE_ERROR,\n    )\n\n    import_status = models.CharField(\n        max_length=20,\n        choices=ImportStatus.choices,\n        default=ImportStatus.CREATED,\n        verbose_name=_(\"Job status\"),\n    )\n\n    data_file = models.FileField(\n        max_length=512,\n        storage=tools.select_storage,\n        verbose_name=_(\"Data file\"),\n        upload_to=tools.upload_import_file_to,\n        help_text=_(\"File that contain data to be imported\"),\n    )\n    input_errors_file = models.FileField(\n        max_length=512,\n        null=True,\n        verbose_name=_(\"Input errors file\"),\n        help_text=_(\"File that contain failed rows\"),\n        upload_to=tools.upload_import_file_to,\n    )\n\n    parse_task_id = models.CharField(\n        default=str,\n        max_length=36,\n        verbose_name=_(\"Parsing task ID\"),\n        help_text=_(\"Celery task ID that start `parse_data`\"),\n    )\n\n    import_task_id = models.CharField(\n        max_length=36,\n        default=str,\n        verbose_name=_(\"Import task ID\"),\n        help_text=_(\"Celery task ID that start `import_data`\"),\n    )\n\n    parse_finished = models.DateTimeField(\n        editable=False,\n        null=True,\n        verbose_name=_(\"Parse finished\"),\n    )\n\n    import_started = models.DateTimeField(\n        editable=False,\n        null=True,\n        verbose_name=_(\"Import started\"),\n    )\n\n    import_finished = models.DateTimeField(\n        editable=False,\n        null=True,\n        verbose_name=_(\"Import finished\"),\n    )\n\n    skip_parse_step = models.BooleanField(\n        default=False,\n        help_text=_(\"Start importing without confirmation\"),\n        verbose_name=_(\"Skip parse step\"),\n    )\n\n    force_import = models.BooleanField(\n        default=False,\n        help_text=_(\"Import data with skip invalid rows.\"),\n        verbose_name=_(\"Force import\"),\n    )\n\n    class Meta:\n        verbose_name = _(\"Import job\")\n        verbose_name_plural = _(\"Import jobs\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return string representation.\"\"\"\n        resource_name = pathlib.Path(self.resource_path).suffix.lstrip(\".\")\n\n        return f\"ImportJob(resource={resource_name})\"\n\n    def save(\n        self,\n        force_insert: bool = False,\n        force_update: bool = False,\n        using: str | None = None,\n        update_fields: collections.abc.Iterable[str] | None = None,\n    ) -&gt; None:\n        \"\"\"Start task for data parsing when ImportJob is created.\n\n        Celery task is manually called with `apply_async`, to provide\n        possibility of custom `task_id` with which task will be run.\n\n        \"\"\"\n        is_created = self._state.adding\n        self._save_input_errors_file()\n        super().save(\n            force_insert=force_insert,\n            force_update=force_update,\n            using=using,\n            update_fields=update_fields,\n        )\n        if not is_created:\n            return\n\n        if self.skip_parse_step:\n            self.import_task_id = str(uuid.uuid4())\n            self.import_started = timezone.now()\n            self.save(\n                update_fields=[\n                    \"import_task_id\",\n                    \"import_started\",\n                ],\n            )\n            transaction.on_commit(self._start_import_data_task)\n        else:\n            self.parse_task_id = str(uuid.uuid4())\n            self.save(update_fields=[\"parse_task_id\"])\n            transaction.on_commit(self.start_parse_data_task)\n\n    @property\n    def resource(self) -&gt; CeleryResource:\n        \"\"\"Get initialized resource instance.\"\"\"\n        resource_class = module_loading.import_string(self.resource_path)\n        resource = resource_class(\n            **self.resource_kwargs,\n        )\n        return resource\n\n    @property\n    def progress(self) -&gt; TaskStateInfo | None:\n        \"\"\"Return dict with parsing state.\"\"\"\n        current_task_id = (\n            self.parse_task_id\n            if self.import_status == self.ImportStatus.PARSING\n            else self.import_task_id\n        )\n\n        if (\n            not current_task_id\n            or self.import_status not in self.progress_statuses\n        ):\n            return None\n\n        return self._get_task_state(current_task_id)\n\n    def _check_import_status_correctness(\n        self,\n        expected_statuses: Sequence[ImportStatus],\n    ) -&gt; None:\n        \"\"\"Raise `ValueError` if `ImportJob` is in incorrect state.\"\"\"\n        if self.import_status not in expected_statuses:\n            raise ValueError(\n                f\"ImportJob with id {self.id} has incorrect status: \"\n                f\"`{self.import_status}`. Expected statuses:\"\n                f\" {[status.value for status in expected_statuses]}\",\n            )\n\n    def start_parse_data_task(self) -&gt; None:\n        \"\"\"Start parsing task.\"\"\"\n        from .. import tasks\n\n        tasks.parse_data_task.apply_async(\n            kwargs={\"job_id\": self.pk},\n            task_id=self.parse_task_id,\n        )\n\n    def parse_data(self) -&gt; None:\n        \"\"\"Parse `data_file` and collect results.\n\n        Sets `result` and/or `traceback` and update `status`.\n\n        \"\"\"\n        self._check_import_status_correctness(\n            expected_statuses=(self.ImportStatus.CREATED,),  # type: ignore[arg-type]\n        )\n\n        self.import_status = self.ImportStatus.PARSING\n        self.save(update_fields=[\"import_status\"])\n\n        try:\n            self.result = self._parse_data_inner()\n            self.import_status = (\n                self.ImportStatus.INPUT_ERROR\n                if self.result.has_errors()\n                or self.result.has_validation_errors()\n                else self.ImportStatus.PARSED\n            )\n            self.parse_finished = timezone.now()\n            self.save(\n                update_fields=[\n                    \"import_status\",\n                    \"result\",\n                    \"parse_finished\",\n                ],\n            )\n        except Exception as error:\n            self._handle_error(\n                error_message=str(error),\n                traceback=traceback.format_exc(),\n                exception=error,\n            )\n\n    def _parse_data_inner(self) -&gt; Result:\n        \"\"\"Run import process with `dry_run == True`.\n\n        Returns\n            apps.utils.async_import_export.results.Result instance with\n            parsing results\n\n        \"\"\"\n        dataset = self._get_data_to_import()\n        return self.resource.import_data(\n            dataset,\n            dry_run=True,\n            raise_errors=False,\n            collect_failed_rows=True,\n            force_import=self.force_import,\n        )\n\n    def confirm_import(self) -&gt; None:\n        \"\"\"Update task status to IMPORT_CONFIRMED and start parsing.\n\n        This is \"intermediate\" state between PARSED and IMPORTING and required\n        because of possible latency of celery task start.\n\n        Celery task is manually called with `apply_async`, to provide\n        possibility of custom `task_id` with which task will be run.\n\n        \"\"\"\n        self._check_import_status_correctness(\n            expected_statuses=(self.ImportStatus.PARSED,),  # type: ignore[arg-type]\n        )\n\n        self.import_status = self.ImportStatus.CONFIRMED\n        self.import_task_id = str(uuid.uuid4())\n        self.import_started = timezone.now()\n        self.save(\n            update_fields=[\n                \"import_status\",\n                \"import_started\",\n                \"import_task_id\",\n            ],\n        )\n        transaction.on_commit(self._start_import_data_task)\n\n    def _start_import_data_task(self) -&gt; None:\n        \"\"\"Start import task.\"\"\"\n        from .. import tasks\n\n        tasks.import_data_task.apply_async(\n            kwargs={\"job_id\": self.pk},\n            task_id=self.import_task_id,\n        )\n\n    def import_data(self) -&gt; None:\n        \"\"\"Import data from `data_file` to DB.\"\"\"\n        expected_status = (\n            self.ImportStatus.CREATED\n            if self.skip_parse_step\n            else self.ImportStatus.CONFIRMED\n        )\n        self._check_import_status_correctness(\n            expected_statuses=(expected_status,),  # type: ignore[arg-type]\n        )\n\n        self.import_status = self.ImportStatus.IMPORTING\n        self.save(update_fields=[\"import_status\"])\n        try:\n            self.result = self._import_data_inner()\n            self.import_status = self.ImportStatus.IMPORTED\n            self.import_finished = timezone.now()\n            self.save(\n                update_fields=[\n                    \"import_status\",\n                    \"result\",\n                    \"import_finished\",\n                ],\n            )\n        except Exception as error:\n            self._handle_error(\n                error_message=str(error),\n                traceback=traceback.format_exc(),\n                exception=error,\n            )\n\n    def _import_data_inner(self) -&gt; Result:\n        \"\"\"Run import process with saving to DB.\n\n        Transaction is not used as import is slow, so before it finish -\n        no instances are saved to DB. So sync works incorrect\n\n        Returns\n            import_export.results.Result instance with parsing results\n\n        \"\"\"\n        data_to_import = self._get_data_to_import()\n        return self.resource.import_data(\n            data_to_import,\n            dry_run=False,\n            raise_errors=True,\n            use_transactions=True,\n            collect_failed_rows=True,\n            force_import=self.force_import,\n        )\n\n    def _get_import_format_by_ext(\n        self,\n        file_ext: str,\n    ) -&gt; type[base_formats.Format]:\n        \"\"\"Determine import file format by file extension.\"\"\"\n        supported_formats = self.resource.get_supported_formats()\n\n        for import_format in supported_formats:\n            if import_format().get_title().upper() == file_ext.upper().replace(\n                \".\",\n                \"\",\n            ):\n                return import_format\n\n        supported_formats_titles = \",\".join(\n            supported_format().get_title()\n            for supported_format in supported_formats\n        )\n        raise ValueError(\n            f\"Incorrect import format: {file_ext}. \"\n            f\"Supported formats: {supported_formats_titles}\",\n        )\n\n    def _get_data_to_import(self) -&gt; tablib.Dataset:\n        \"\"\"Read ``self.data_file`` content and convert it to dataset.\"\"\"\n        file_ext = pathlib.Path(self.data_file.name).suffix\n        input_format = self._get_import_format_by_ext(\n            file_ext=file_ext,\n        )()\n        data = self.data_file.read()\n        self.data_file.seek(0)\n        if not input_format.is_binary():\n            data = encoding.force_str(data)\n        data_to_import = input_format.create_dataset(data)\n        num_rows = len(data_to_import)\n        if num_rows &gt; settings.IMPORT_EXPORT_MAX_DATASET_ROWS:\n            raise ValueError(\n                f\"Too many rows `{num_rows}`\"\n                f\"(Max: {settings.IMPORT_EXPORT_MAX_DATASET_ROWS}). \"\n                f\"Input file may be broken. \"\n                f\"If it's spreadsheet file, please delete empty rows.\",\n            )\n        return data_to_import\n\n    def cancel_import(self) -&gt; None:\n        \"\"\"Cancel current data import.\n\n        ImportJob can be CANCELLED only from following states:\n            - CREATED\n            - PARSING\n            - CONFIRMED\n            - IMPORTING\n\n        \"\"\"\n        status_task_field_map = {\n            self.ImportStatus.CREATED: \"parse_task_id\",\n            self.ImportStatus.PARSING: \"parse_task_id\",\n            self.ImportStatus.CONFIRMED: \"import_task_id\",\n            self.ImportStatus.IMPORTING: \"import_task_id\",\n        }\n        self._check_import_status_correctness(\n            expected_statuses=status_task_field_map.keys(),  # type: ignore\n        )\n\n        # send signal to celery to revoke task\n        task_id = getattr(self, status_task_field_map[self.import_status])\n        current_app.control.revoke(task_id, terminate=True)\n\n        self.import_status = self.ImportStatus.CANCELLED\n        self.save(update_fields=[\"import_status\"])\n\n    def _get_task_state(self, task_id: str) -&gt; TaskStateInfo:\n        \"\"\"Get state info for passed task_id.\n\n        This method may change job status if task failed, but we did not\n        save info about this to DB.\n\n        This may happen if task start import/parsing, but processes was killed.\n        In that case, job have status `importing`, but it can't be finished.\n\n        \"\"\"\n        async_result = result.AsyncResult(task_id)\n        if async_result.state in states.EXCEPTION_STATES:\n            self._handle_error(\n                error_message=str(async_result.info),\n                traceback=str(async_result.traceback),\n            )\n            return {\n                \"state\": async_result.state,\n                \"info\": {},\n            }\n        return {\n            \"state\": async_result.state,\n            \"info\": async_result.info,\n        }\n\n    def _handle_error(\n        self,\n        error_message: str,\n        traceback: str,\n        exception: Exception | None = None,\n    ) -&gt; None:\n        \"\"\"Update job's status in case of error.\"\"\"\n        self.import_status = (\n            self.ImportStatus.PARSE_ERROR\n            if self.import_status == self.ImportStatus.PARSING\n            else self.ImportStatus.IMPORT_ERROR\n        )\n        error_message_limit = self._meta.get_field(\"error_message\").max_length\n        self.error_message = error_message[:error_message_limit]\n        self.traceback = traceback\n        self.save(\n            update_fields=[\n                \"error_message\",\n                \"traceback\",\n                \"import_status\",\n            ],\n        )\n        signals.import_job_failed.send(\n            sender=self.__class__,\n            instance=self,\n            error_message=self.error_message,\n            traceback=self.traceback,\n            exception=exception,\n        )\n\n    def _save_input_errors_file(self) -&gt; None:\n        \"\"\"Save input errors file.\n\n        This should be saved after parsing and after importing\n        and if there are row errors in result.\n\n        \"\"\"\n        if (\n            self.import_status not in self.results_statuses\n            or not self.result\n            or not self.result.row_errors()\n            or self.input_errors_file\n        ):\n            return\n        file_ext = pathlib.Path(self.data_file.name).suffix\n        file_format = self._get_import_format_by_ext(\n            file_ext=file_ext,\n        )()\n        export_data = file_format.export_data(\n            dataset=self.result.failed_dataset,\n        )\n\n        # create file if `export_data` is not file\n        if not hasattr(export_data, \"read\"):\n            export_data = django_files.ContentFile(\n                encoding.force_bytes(export_data),\n            )\n\n        file_name = self.resource.generate_export_filename(\n            file_format,\n        ).replace(\"/\", \"-\")\n\n        self.input_errors_file.save(\n            name=f\"FailedRows{file_name}\",\n            content=export_data,\n            save=True,\n        )\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.export_filename","title":"<code>export_filename</code>  <code>property</code>","text":"<p>Get filename for export result file.</p>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.file_format","title":"<code>file_format</code>  <code>property</code>","text":"<p>Get initialized format instance.</p>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Return dict with export state.</p>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.ExportStatus","title":"<code>ExportStatus</code>","text":"<p>               Bases: <code>TextChoices</code></p> <p>ExportJob possible statuses.</p> <ul> <li>CREATED:     export job is just created, no exporting done</li> <li>EXPORTING:     export job started</li> <li>EXPORT_ERROR:     DB queryset not exported, errors</li> <li>EXPORTED:     DB queryset exported, no errors occurred</li> </ul> <p>State diagrams:</p> <pre><code>CREATED\n   |\nEXPORTING  - (EXPORT_ERROR)\n   |\nEXPORTED\n</code></pre> Source code in <code>import_export_extensions/models/export_job.py</code> <pre><code>class ExportStatus(models.TextChoices):\n    \"\"\"ExportJob possible statuses.\n\n    * CREATED:\n        export job is just created, no exporting done\n    * EXPORTING:\n        export job started\n    * EXPORT_ERROR:\n        DB queryset not exported, errors\n    * EXPORTED:\n        DB queryset exported, no errors occurred\n\n    State diagrams:\n\n        CREATED\n           |\n        EXPORTING  - (EXPORT_ERROR)\n           |\n        EXPORTED\n\n    \"\"\"\n\n    CREATED = \"CREATED\", _(\"Created\")\n    EXPORTING = \"EXPORTING\", _(\"Exporting\")\n    EXPORT_ERROR = \"EXPORT_ERROR\", _(\"Export Error\")\n    EXPORTED = \"EXPORTED\", _(\"Exported\")\n    CANCELLED = \"CANCELLED\", _(\"Cancelled\")\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation.</p> Source code in <code>import_export_extensions/models/export_job.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    resource_name = pathlib.Path(self.resource_path).suffix.lstrip(\".\")\n    file_format = pathlib.Path(self.file_format_path).suffix.lstrip(\".\")\n\n    return f\"ExportJob(resource={resource_name}, {file_format=})\"\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.cancel_export","title":"<code>cancel_export()</code>","text":"<p>Cancel current data export.</p> ExportJob can be CANCELLED only from following states <ul> <li>CREATED</li> <li>EXPORTING</li> </ul> Source code in <code>import_export_extensions/models/export_job.py</code> <pre><code>def cancel_export(self) -&gt; None:\n    \"\"\"Cancel current data export.\n\n    ExportJob can be CANCELLED only from following states:\n        - CREATED\n        - EXPORTING\n\n    \"\"\"\n    self._check_export_status_correctness(\n        expected_statuses=(  # type: ignore\n            self.ExportStatus.CREATED,\n            self.ExportStatus.EXPORTING,\n        ),\n    )\n\n    # send signal to celery to revoke task\n    current_app.control.revoke(self.export_task_id, terminate=True)\n\n    self.export_status = self.ExportStatus.CANCELLED\n    self.save(update_fields=[\"export_status\"])\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.export_data","title":"<code>export_data()</code>","text":"<p>Export data to <code>data_file</code> from DB.</p> Source code in <code>import_export_extensions/models/export_job.py</code> <pre><code>def export_data(self) -&gt; None:\n    \"\"\"Export data to `data_file` from DB.\"\"\"\n    self.export_status = self.ExportStatus.EXPORTING\n    self.export_started = timezone.now()\n    self.save(\n        update_fields=[\n            \"export_status\",\n            \"export_started\",\n        ],\n    )\n    try:\n        self._export_data_inner()\n        self.export_status = self.ExportStatus.EXPORTED\n        self.export_finished = timezone.now()\n        self.save(\n            update_fields=[\n                \"export_status\",\n                \"export_finished\",\n            ],\n        )\n    except Exception as error:\n        self._handle_error(\n            error_message=str(error),\n            traceback=traceback.format_exc(),\n            exception=error,\n        )\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ExportJob.save","title":"<code>save(force_insert=False, force_update=False, using=None, update_fields=None)</code>","text":"<p>Start task for data exporting when ExportJob is created.</p> <p>Celery task is manually called with <code>apply_async</code>, to provide possibility of custom <code>task_id</code> with which task will be run.</p> Source code in <code>import_export_extensions/models/export_job.py</code> <pre><code>def save(\n    self,\n    force_insert: bool = False,\n    force_update: bool = False,\n    using: str | None = None,\n    update_fields: collections.abc.Iterable[str] | None = None,\n) -&gt; None:\n    \"\"\"Start task for data exporting when ExportJob is created.\n\n    Celery task is manually called with `apply_async`, to provide\n    possibility of custom `task_id` with which task will be run.\n\n    \"\"\"\n    is_created = self._state.adding\n    super().save(\n        force_insert=force_insert,\n        force_update=force_update,\n        using=using,\n        update_fields=update_fields,\n    )\n    if is_created:\n        self.export_task_id = str(uuid.uuid4())\n        self.save(update_fields=[\"export_task_id\"])\n        transaction.on_commit(self._start_export_data_task)\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Return dict with parsing state.</p>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.resource","title":"<code>resource</code>  <code>property</code>","text":"<p>Get initialized resource instance.</p>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.ImportStatus","title":"<code>ImportStatus</code>","text":"<p>               Bases: <code>TextChoices</code></p> <p>ImportJob possible statuses.</p> <ul> <li>CREATED:     import job is just created, no parsing done</li> <li>PARSING:     parse job started</li> <li>PARSED:     data_file parsed, no errors in data occurred</li> <li>INPUT_ERROR:     data_file parsed, data contains errors</li> <li>PARSE_ERROR:     data_file can't be parsed (invalid format, etc.)</li> <li>IMPORT_CONFIRMED     import confirmed but not started yet</li> <li>IMPORTING:     importing job started</li> <li>IMPORTED:     data from data_file imported to DB w/o errors</li> <li>IMPORT_ERROR:     unknown error during import</li> <li>CANCELLED:     import job has been cancelled (revoked)</li> </ul> <p>State diagrams:</p> <pre><code>CREATED\n   |\n.parse_data()\n   |\nPARSING  - (INPUT_ERROR, PARSE_ERROR)\n   |\nPARSED\n   |\n.confirm_import()\n   |\nIMPORT_CONFIRMED\n   |\n.import_data()\n   |\nIMPORTING - IMPORT_ERROR\n   |\nIMPORTED\n</code></pre> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>class ImportStatus(models.TextChoices):\n    \"\"\"ImportJob possible statuses.\n\n    * CREATED:\n        import job is just created, no parsing done\n    * PARSING:\n        parse job started\n    * PARSED:\n        data_file parsed, no errors in data occurred\n    * INPUT_ERROR:\n        data_file parsed, data contains errors\n    * PARSE_ERROR:\n        data_file can't be parsed (invalid format, etc.)\n    * IMPORT_CONFIRMED\n        import confirmed but not started yet\n    * IMPORTING:\n        importing job started\n    * IMPORTED:\n        data from data_file imported to DB w/o errors\n    * IMPORT_ERROR:\n        unknown error during import\n    * CANCELLED:\n        import job has been cancelled (revoked)\n\n    State diagrams:\n\n        CREATED\n           |\n        .parse_data()\n           |\n        PARSING  - (INPUT_ERROR, PARSE_ERROR)\n           |\n        PARSED\n           |\n        .confirm_import()\n           |\n        IMPORT_CONFIRMED\n           |\n        .import_data()\n           |\n        IMPORTING - IMPORT_ERROR\n           |\n        IMPORTED\n\n    \"\"\"\n\n    CREATED = \"CREATED\", _(\"Created\")\n    PARSING = \"PARSING\", _(\"Parsing\")\n    PARSED = \"PARSED\", _(\"Parsed\")\n    INPUT_ERROR = \"INPUT_ERROR\", _(\"Input data error\")\n    PARSE_ERROR = \"PARSE_ERROR\", _(\"Parse error\")\n    CONFIRMED = \"CONFIRMED\", _(\"Import confirmed\")\n    IMPORTING = \"IMPORTING\", _(\"Importing\")\n    IMPORTED = \"IMPORTED\", _(\"Imported\")\n    IMPORT_ERROR = \"IMPORT_ERROR\", _(\"Import error\")\n    CANCELLED = \"CANCELLED\", _(\"Cancelled\")\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation.</p> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return string representation.\"\"\"\n    resource_name = pathlib.Path(self.resource_path).suffix.lstrip(\".\")\n\n    return f\"ImportJob(resource={resource_name})\"\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.cancel_import","title":"<code>cancel_import()</code>","text":"<p>Cancel current data import.</p> ImportJob can be CANCELLED only from following states <ul> <li>CREATED</li> <li>PARSING</li> <li>CONFIRMED</li> <li>IMPORTING</li> </ul> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def cancel_import(self) -&gt; None:\n    \"\"\"Cancel current data import.\n\n    ImportJob can be CANCELLED only from following states:\n        - CREATED\n        - PARSING\n        - CONFIRMED\n        - IMPORTING\n\n    \"\"\"\n    status_task_field_map = {\n        self.ImportStatus.CREATED: \"parse_task_id\",\n        self.ImportStatus.PARSING: \"parse_task_id\",\n        self.ImportStatus.CONFIRMED: \"import_task_id\",\n        self.ImportStatus.IMPORTING: \"import_task_id\",\n    }\n    self._check_import_status_correctness(\n        expected_statuses=status_task_field_map.keys(),  # type: ignore\n    )\n\n    # send signal to celery to revoke task\n    task_id = getattr(self, status_task_field_map[self.import_status])\n    current_app.control.revoke(task_id, terminate=True)\n\n    self.import_status = self.ImportStatus.CANCELLED\n    self.save(update_fields=[\"import_status\"])\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.confirm_import","title":"<code>confirm_import()</code>","text":"<p>Update task status to IMPORT_CONFIRMED and start parsing.</p> <p>This is \"intermediate\" state between PARSED and IMPORTING and required because of possible latency of celery task start.</p> <p>Celery task is manually called with <code>apply_async</code>, to provide possibility of custom <code>task_id</code> with which task will be run.</p> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def confirm_import(self) -&gt; None:\n    \"\"\"Update task status to IMPORT_CONFIRMED and start parsing.\n\n    This is \"intermediate\" state between PARSED and IMPORTING and required\n    because of possible latency of celery task start.\n\n    Celery task is manually called with `apply_async`, to provide\n    possibility of custom `task_id` with which task will be run.\n\n    \"\"\"\n    self._check_import_status_correctness(\n        expected_statuses=(self.ImportStatus.PARSED,),  # type: ignore[arg-type]\n    )\n\n    self.import_status = self.ImportStatus.CONFIRMED\n    self.import_task_id = str(uuid.uuid4())\n    self.import_started = timezone.now()\n    self.save(\n        update_fields=[\n            \"import_status\",\n            \"import_started\",\n            \"import_task_id\",\n        ],\n    )\n    transaction.on_commit(self._start_import_data_task)\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.import_data","title":"<code>import_data()</code>","text":"<p>Import data from <code>data_file</code> to DB.</p> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def import_data(self) -&gt; None:\n    \"\"\"Import data from `data_file` to DB.\"\"\"\n    expected_status = (\n        self.ImportStatus.CREATED\n        if self.skip_parse_step\n        else self.ImportStatus.CONFIRMED\n    )\n    self._check_import_status_correctness(\n        expected_statuses=(expected_status,),  # type: ignore[arg-type]\n    )\n\n    self.import_status = self.ImportStatus.IMPORTING\n    self.save(update_fields=[\"import_status\"])\n    try:\n        self.result = self._import_data_inner()\n        self.import_status = self.ImportStatus.IMPORTED\n        self.import_finished = timezone.now()\n        self.save(\n            update_fields=[\n                \"import_status\",\n                \"result\",\n                \"import_finished\",\n            ],\n        )\n    except Exception as error:\n        self._handle_error(\n            error_message=str(error),\n            traceback=traceback.format_exc(),\n            exception=error,\n        )\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.parse_data","title":"<code>parse_data()</code>","text":"<p>Parse <code>data_file</code> and collect results.</p> <p>Sets <code>result</code> and/or <code>traceback</code> and update <code>status</code>.</p> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def parse_data(self) -&gt; None:\n    \"\"\"Parse `data_file` and collect results.\n\n    Sets `result` and/or `traceback` and update `status`.\n\n    \"\"\"\n    self._check_import_status_correctness(\n        expected_statuses=(self.ImportStatus.CREATED,),  # type: ignore[arg-type]\n    )\n\n    self.import_status = self.ImportStatus.PARSING\n    self.save(update_fields=[\"import_status\"])\n\n    try:\n        self.result = self._parse_data_inner()\n        self.import_status = (\n            self.ImportStatus.INPUT_ERROR\n            if self.result.has_errors()\n            or self.result.has_validation_errors()\n            else self.ImportStatus.PARSED\n        )\n        self.parse_finished = timezone.now()\n        self.save(\n            update_fields=[\n                \"import_status\",\n                \"result\",\n                \"parse_finished\",\n            ],\n        )\n    except Exception as error:\n        self._handle_error(\n            error_message=str(error),\n            traceback=traceback.format_exc(),\n            exception=error,\n        )\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.save","title":"<code>save(force_insert=False, force_update=False, using=None, update_fields=None)</code>","text":"<p>Start task for data parsing when ImportJob is created.</p> <p>Celery task is manually called with <code>apply_async</code>, to provide possibility of custom <code>task_id</code> with which task will be run.</p> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def save(\n    self,\n    force_insert: bool = False,\n    force_update: bool = False,\n    using: str | None = None,\n    update_fields: collections.abc.Iterable[str] | None = None,\n) -&gt; None:\n    \"\"\"Start task for data parsing when ImportJob is created.\n\n    Celery task is manually called with `apply_async`, to provide\n    possibility of custom `task_id` with which task will be run.\n\n    \"\"\"\n    is_created = self._state.adding\n    self._save_input_errors_file()\n    super().save(\n        force_insert=force_insert,\n        force_update=force_update,\n        using=using,\n        update_fields=update_fields,\n    )\n    if not is_created:\n        return\n\n    if self.skip_parse_step:\n        self.import_task_id = str(uuid.uuid4())\n        self.import_started = timezone.now()\n        self.save(\n            update_fields=[\n                \"import_task_id\",\n                \"import_started\",\n            ],\n        )\n        transaction.on_commit(self._start_import_data_task)\n    else:\n        self.parse_task_id = str(uuid.uuid4())\n        self.save(update_fields=[\"parse_task_id\"])\n        transaction.on_commit(self.start_parse_data_task)\n</code></pre>"},{"location":"reference/models/#import_export_extensions.models.ImportJob.start_parse_data_task","title":"<code>start_parse_data_task()</code>","text":"<p>Start parsing task.</p> Source code in <code>import_export_extensions/models/import_job.py</code> <pre><code>def start_parse_data_task(self) -&gt; None:\n    \"\"\"Start parsing task.\"\"\"\n    from .. import tasks\n\n    tasks.parse_data_task.apply_async(\n        kwargs={\"job_id\": self.pk},\n        task_id=self.parse_task_id,\n    )\n</code></pre>"}]}